"use client";

// src/context/providers/AssistantRuntimeProvider.tsx
import { memo, useEffect, useMemo, useState } from "react";
import { AssistantContext } from "../react/AssistantContext.mjs";
import { makeAssistantToolUIsStore } from "../stores/AssistantToolUIs.mjs";
import { ThreadRuntimeProvider } from "./ThreadRuntimeProvider.mjs";
import { create } from "zustand";
import { writableStore } from "../ReadonlyStore.mjs";
import { jsx } from "react/jsx-runtime";
var useAssistantRuntimeStore = (runtime) => {
  const [store] = useState(() => create(() => runtime));
  useEffect(() => {
    writableStore(store).setState(runtime, true);
  }, [runtime, store]);
  return store;
};
var useAssistantToolUIsStore = () => {
  return useMemo(() => makeAssistantToolUIsStore(), []);
};
var useThreadListStore = (runtime) => {
  const [store] = useState(() => create(() => runtime.threadList.getState()));
  useEffect(() => {
    const updateState = () => writableStore(store).setState(runtime.threadList.getState(), true);
    updateState();
    return runtime.threadList.subscribe(updateState);
  }, [runtime, store]);
  return store;
};
var AssistantRuntimeProviderImpl = ({ children, runtime }) => {
  const useAssistantRuntime = useAssistantRuntimeStore(runtime);
  const useToolUIs = useAssistantToolUIsStore();
  const useThreadList = useThreadListStore(runtime);
  const context = useMemo(() => {
    return {
      useToolUIs,
      useAssistantRuntime,
      useAssistantActions: useAssistantRuntime,
      useThreadList
    };
  }, [useAssistantRuntime, useToolUIs, useThreadList]);
  return /* @__PURE__ */ jsx(AssistantContext.Provider, { value: context, children: /* @__PURE__ */ jsx(ThreadRuntimeProvider, { runtime: runtime.thread, children }) });
};
var AssistantRuntimeProvider = memo(AssistantRuntimeProviderImpl);
export {
  AssistantRuntimeProvider,
  AssistantRuntimeProviderImpl
};
//# sourceMappingURL=AssistantRuntimeProvider.mjs.map