import type { ThreadViewportState } from "../stores/ThreadViewport";
import { ReadonlyStore } from "../ReadonlyStore";
import { UseBoundStore } from "zustand";
import { ThreadRuntime } from "../../api/ThreadRuntime";
import { ThreadState } from "../../api/ThreadRuntime";
import { ModelConfig, ThreadMessage } from "../../types";
import { ThreadComposerState } from "../../api/ComposerRuntime";
export type ThreadContextValue = {
    useThread: UseBoundStore<ReadonlyStore<ThreadState>>;
    /**
     * @deprecated Use `useThreadRuntime` instead. This will be removed in 0.6.0.
     */
    useThreadActions: UseBoundStore<ReadonlyStore<ThreadRuntime>>;
    useThreadRuntime: UseBoundStore<ReadonlyStore<ThreadRuntime>>;
    useThreadMessages: UseBoundStore<ReadonlyStore<readonly ThreadMessage[]>>;
    useComposer: UseBoundStore<ReadonlyStore<ThreadComposerState>>;
    useViewport: UseBoundStore<ReadonlyStore<ThreadViewportState>>;
};
export declare const ThreadContext: import("react").Context<ThreadContextValue | null>;
export declare const useThreadContext: {
    (options?: {
        optional?: false | undefined;
    } | undefined): ThreadContextValue;
    (options?: {
        optional?: boolean | undefined;
    } | undefined): ThreadContextValue | null;
};
export declare function useThreadRuntime(options?: {
    optional?: false | undefined;
}): ThreadRuntime;
export declare function useThreadRuntime(options?: {
    optional?: boolean | undefined;
}): ThreadRuntime | null;
export declare const actions: {
    useThreadActions: {
        (): Readonly<{
            readonly path: import("../../api/RuntimePathTypes").ThreadRuntimePath;
            readonly composer: import("../..").ThreadComposerRuntime;
            getState(): Readonly<{
                threadId: string;
                isDisabled: boolean;
                isRunning: boolean;
                capabilities: Readonly<{
                    switchToBranch: boolean;
                    edit: boolean;
                    reload: boolean;
                    cancel: boolean;
                    unstable_copy: boolean;
                    speech: boolean;
                    attachments: boolean;
                    feedback: boolean;
                }>;
                messages: readonly ThreadMessage[];
                suggestions: readonly import("../..").ThreadSuggestion[];
                extras: unknown;
                speech: Readonly<{
                    messageId: string;
                    status: import("../..").SpeechSynthesisAdapter.Status;
                }> | undefined;
            }>;
            unstable_getCore(): Readonly<{
                getMessageById: (messageId: string) => {
                    parentId: string | null;
                    message: ThreadMessage;
                } | undefined;
                getBranches: (messageId: string) => readonly string[];
                switchToBranch: (branchId: string) => void;
                append: (message: import("../..").AppendMessage) => void;
                startRun: (parentId: string | null) => void;
                cancelRun: () => void;
                addToolResult: (options: import("../..").AddToolResultOptions) => void;
                speak: (messageId: string) => void;
                stopSpeaking: () => void;
                getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
                submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
                getModelConfig: () => ModelConfig;
                composer: import("../../runtimes/core/ComposerRuntimeCore").ThreadComposerRuntimeCore;
                getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
                beginEdit: (messageId: string) => void;
                speech: Readonly<{
                    messageId: string;
                    status: import("../..").SpeechSynthesisAdapter.Status;
                }> | undefined;
                capabilities: Readonly<Readonly<{
                    switchToBranch: boolean;
                    edit: boolean;
                    reload: boolean;
                    cancel: boolean;
                    unstable_copy: boolean;
                    speech: boolean;
                    attachments: boolean;
                    feedback: boolean;
                }>>;
                threadId: string;
                isDisabled: boolean;
                messages: readonly ThreadMessage[];
                suggestions: readonly import("../..").ThreadSuggestion[];
                extras: unknown;
                subscribe: (callback: () => void) => import("../..").Unsubscribe;
                import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
                export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
                unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
            }>;
            append(message: import("../../api/ThreadRuntime").CreateAppendMessage): void;
            startRun(parentId: string | null): void;
            subscribe(callback: () => void): import("../..").Unsubscribe;
            cancelRun(): void;
            getModelConfig(): ModelConfig;
            export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
            import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
            getMesssageByIndex(idx: number): import("../..").MessageRuntime;
            getMesssageById(messageId: string): import("../..").MessageRuntime;
            stopSpeaking: () => void;
            unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
            capabilities: Readonly<Readonly<{
                switchToBranch: boolean;
                edit: boolean;
                reload: boolean;
                cancel: boolean;
                unstable_copy: boolean;
                speech: boolean;
                attachments: boolean;
                feedback: boolean;
            }>>;
            threadId: string;
            isDisabled: boolean;
            isRunning: boolean;
            messages: readonly ThreadMessage[];
            suggestions: readonly import("../..").ThreadSuggestion[];
            speech: Readonly<{
                messageId: string;
                status: import("../..").SpeechSynthesisAdapter.Status;
            }> | undefined;
            extras: unknown;
            getBranches: (messageId: string) => readonly string[];
            switchToBranch: (branchId: string) => void;
            addToolResult: (options: import("../..").AddToolResultOptions) => void;
            speak: (messageId: string) => void;
            getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
            submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
            getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
            beginEdit: (messageId: string) => void;
        }>;
        <TSelected>(selector: (state: Readonly<{
            readonly path: import("../../api/RuntimePathTypes").ThreadRuntimePath;
            readonly composer: import("../..").ThreadComposerRuntime;
            getState(): Readonly<{
                threadId: string;
                isDisabled: boolean;
                isRunning: boolean;
                capabilities: Readonly<{
                    switchToBranch: boolean;
                    edit: boolean;
                    reload: boolean;
                    cancel: boolean;
                    unstable_copy: boolean;
                    speech: boolean;
                    attachments: boolean;
                    feedback: boolean;
                }>;
                messages: readonly ThreadMessage[];
                suggestions: readonly import("../..").ThreadSuggestion[];
                extras: unknown;
                speech: Readonly<{
                    messageId: string;
                    status: import("../..").SpeechSynthesisAdapter.Status;
                }> | undefined;
            }>;
            unstable_getCore(): Readonly<{
                getMessageById: (messageId: string) => {
                    parentId: string | null;
                    message: ThreadMessage;
                } | undefined;
                getBranches: (messageId: string) => readonly string[];
                switchToBranch: (branchId: string) => void;
                append: (message: import("../..").AppendMessage) => void;
                startRun: (parentId: string | null) => void;
                cancelRun: () => void;
                addToolResult: (options: import("../..").AddToolResultOptions) => void;
                speak: (messageId: string) => void;
                stopSpeaking: () => void;
                getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
                submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
                getModelConfig: () => ModelConfig;
                composer: import("../../runtimes/core/ComposerRuntimeCore").ThreadComposerRuntimeCore;
                getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
                beginEdit: (messageId: string) => void;
                speech: Readonly<{
                    messageId: string;
                    status: import("../..").SpeechSynthesisAdapter.Status;
                }> | undefined;
                capabilities: Readonly<Readonly<{
                    switchToBranch: boolean;
                    edit: boolean;
                    reload: boolean;
                    cancel: boolean;
                    unstable_copy: boolean;
                    speech: boolean;
                    attachments: boolean;
                    feedback: boolean;
                }>>;
                threadId: string;
                isDisabled: boolean;
                messages: readonly ThreadMessage[];
                suggestions: readonly import("../..").ThreadSuggestion[];
                extras: unknown;
                subscribe: (callback: () => void) => import("../..").Unsubscribe;
                import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
                export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
                unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
            }>;
            append(message: import("../../api/ThreadRuntime").CreateAppendMessage): void;
            startRun(parentId: string | null): void;
            subscribe(callback: () => void): import("../..").Unsubscribe;
            cancelRun(): void;
            getModelConfig(): ModelConfig;
            export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
            import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
            getMesssageByIndex(idx: number): import("../..").MessageRuntime;
            getMesssageById(messageId: string): import("../..").MessageRuntime;
            stopSpeaking: () => void;
            unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
            capabilities: Readonly<Readonly<{
                switchToBranch: boolean;
                edit: boolean;
                reload: boolean;
                cancel: boolean;
                unstable_copy: boolean;
                speech: boolean;
                attachments: boolean;
                feedback: boolean;
            }>>;
            threadId: string;
            isDisabled: boolean;
            isRunning: boolean;
            messages: readonly ThreadMessage[];
            suggestions: readonly import("../..").ThreadSuggestion[];
            speech: Readonly<{
                messageId: string;
                status: import("../..").SpeechSynthesisAdapter.Status;
            }> | undefined;
            extras: unknown;
            getBranches: (messageId: string) => readonly string[];
            switchToBranch: (branchId: string) => void;
            addToolResult: (options: import("../..").AddToolResultOptions) => void;
            speak: (messageId: string) => void;
            getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
            submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
            getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
            beginEdit: (messageId: string) => void;
        }>) => TSelected): TSelected;
        (options: {
            optional: true;
        }): Readonly<{
            readonly path: import("../../api/RuntimePathTypes").ThreadRuntimePath;
            readonly composer: import("../..").ThreadComposerRuntime;
            getState(): Readonly<{
                threadId: string;
                isDisabled: boolean;
                isRunning: boolean;
                capabilities: Readonly<{
                    switchToBranch: boolean;
                    edit: boolean;
                    reload: boolean;
                    cancel: boolean;
                    unstable_copy: boolean;
                    speech: boolean;
                    attachments: boolean;
                    feedback: boolean;
                }>;
                messages: readonly ThreadMessage[];
                suggestions: readonly import("../..").ThreadSuggestion[];
                extras: unknown;
                speech: Readonly<{
                    messageId: string;
                    status: import("../..").SpeechSynthesisAdapter.Status;
                }> | undefined;
            }>;
            unstable_getCore(): Readonly<{
                getMessageById: (messageId: string) => {
                    parentId: string | null;
                    message: ThreadMessage;
                } | undefined;
                getBranches: (messageId: string) => readonly string[];
                switchToBranch: (branchId: string) => void;
                append: (message: import("../..").AppendMessage) => void;
                startRun: (parentId: string | null) => void;
                cancelRun: () => void;
                addToolResult: (options: import("../..").AddToolResultOptions) => void;
                speak: (messageId: string) => void;
                stopSpeaking: () => void;
                getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
                submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
                getModelConfig: () => ModelConfig;
                composer: import("../../runtimes/core/ComposerRuntimeCore").ThreadComposerRuntimeCore;
                getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
                beginEdit: (messageId: string) => void;
                speech: Readonly<{
                    messageId: string;
                    status: import("../..").SpeechSynthesisAdapter.Status;
                }> | undefined;
                capabilities: Readonly<Readonly<{
                    switchToBranch: boolean;
                    edit: boolean;
                    reload: boolean;
                    cancel: boolean;
                    unstable_copy: boolean;
                    speech: boolean;
                    attachments: boolean;
                    feedback: boolean;
                }>>;
                threadId: string;
                isDisabled: boolean;
                messages: readonly ThreadMessage[];
                suggestions: readonly import("../..").ThreadSuggestion[];
                extras: unknown;
                subscribe: (callback: () => void) => import("../..").Unsubscribe;
                import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
                export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
                unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
            }>;
            append(message: import("../../api/ThreadRuntime").CreateAppendMessage): void;
            startRun(parentId: string | null): void;
            subscribe(callback: () => void): import("../..").Unsubscribe;
            cancelRun(): void;
            getModelConfig(): ModelConfig;
            export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
            import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
            getMesssageByIndex(idx: number): import("../..").MessageRuntime;
            getMesssageById(messageId: string): import("../..").MessageRuntime;
            stopSpeaking: () => void;
            unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
            capabilities: Readonly<Readonly<{
                switchToBranch: boolean;
                edit: boolean;
                reload: boolean;
                cancel: boolean;
                unstable_copy: boolean;
                speech: boolean;
                attachments: boolean;
                feedback: boolean;
            }>>;
            threadId: string;
            isDisabled: boolean;
            isRunning: boolean;
            messages: readonly ThreadMessage[];
            suggestions: readonly import("../..").ThreadSuggestion[];
            speech: Readonly<{
                messageId: string;
                status: import("../..").SpeechSynthesisAdapter.Status;
            }> | undefined;
            extras: unknown;
            getBranches: (messageId: string) => readonly string[];
            switchToBranch: (branchId: string) => void;
            addToolResult: (options: import("../..").AddToolResultOptions) => void;
            speak: (messageId: string) => void;
            getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
            submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
            getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
            beginEdit: (messageId: string) => void;
        }> | null;
        <TSelected>(options: {
            optional: true;
            selector?: (state: Readonly<{
                readonly path: import("../../api/RuntimePathTypes").ThreadRuntimePath;
                readonly composer: import("../..").ThreadComposerRuntime;
                getState(): Readonly<{
                    threadId: string;
                    isDisabled: boolean;
                    isRunning: boolean;
                    capabilities: Readonly<{
                        switchToBranch: boolean;
                        edit: boolean;
                        reload: boolean;
                        cancel: boolean;
                        unstable_copy: boolean;
                        speech: boolean;
                        attachments: boolean;
                        feedback: boolean;
                    }>;
                    messages: readonly ThreadMessage[];
                    suggestions: readonly import("../..").ThreadSuggestion[];
                    extras: unknown;
                    speech: Readonly<{
                        messageId: string;
                        status: import("../..").SpeechSynthesisAdapter.Status;
                    }> | undefined;
                }>;
                unstable_getCore(): Readonly<{
                    getMessageById: (messageId: string) => {
                        parentId: string | null;
                        message: ThreadMessage;
                    } | undefined;
                    getBranches: (messageId: string) => readonly string[];
                    switchToBranch: (branchId: string) => void;
                    append: (message: import("../..").AppendMessage) => void;
                    startRun: (parentId: string | null) => void;
                    cancelRun: () => void;
                    addToolResult: (options: import("../..").AddToolResultOptions) => void;
                    speak: (messageId: string) => void;
                    stopSpeaking: () => void;
                    getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
                    submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
                    getModelConfig: () => ModelConfig;
                    composer: import("../../runtimes/core/ComposerRuntimeCore").ThreadComposerRuntimeCore;
                    getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
                    beginEdit: (messageId: string) => void;
                    speech: Readonly<{
                        messageId: string;
                        status: import("../..").SpeechSynthesisAdapter.Status;
                    }> | undefined;
                    capabilities: Readonly<Readonly<{
                        switchToBranch: boolean;
                        edit: boolean;
                        reload: boolean;
                        cancel: boolean;
                        unstable_copy: boolean;
                        speech: boolean;
                        attachments: boolean;
                        feedback: boolean;
                    }>>;
                    threadId: string;
                    isDisabled: boolean;
                    messages: readonly ThreadMessage[];
                    suggestions: readonly import("../..").ThreadSuggestion[];
                    extras: unknown;
                    subscribe: (callback: () => void) => import("../..").Unsubscribe;
                    import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
                    export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
                    unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
                }>;
                append(message: import("../../api/ThreadRuntime").CreateAppendMessage): void;
                startRun(parentId: string | null): void;
                subscribe(callback: () => void): import("../..").Unsubscribe;
                cancelRun(): void;
                getModelConfig(): ModelConfig;
                export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
                import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
                getMesssageByIndex(idx: number): import("../..").MessageRuntime;
                getMesssageById(messageId: string): import("../..").MessageRuntime;
                stopSpeaking: () => void;
                unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
                capabilities: Readonly<Readonly<{
                    switchToBranch: boolean;
                    edit: boolean;
                    reload: boolean;
                    cancel: boolean;
                    unstable_copy: boolean;
                    speech: boolean;
                    attachments: boolean;
                    feedback: boolean;
                }>>;
                threadId: string;
                isDisabled: boolean;
                isRunning: boolean;
                messages: readonly ThreadMessage[];
                suggestions: readonly import("../..").ThreadSuggestion[];
                speech: Readonly<{
                    messageId: string;
                    status: import("../..").SpeechSynthesisAdapter.Status;
                }> | undefined;
                extras: unknown;
                getBranches: (messageId: string) => readonly string[];
                switchToBranch: (branchId: string) => void;
                addToolResult: (options: import("../..").AddToolResultOptions) => void;
                speak: (messageId: string) => void;
                getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
                submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
                getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
                beginEdit: (messageId: string) => void;
            }>) => TSelected;
        }): TSelected | null;
    };
} & {
    useThreadActionsStore: {
        (): ReadonlyStore<Readonly<{
            readonly path: import("../../api/RuntimePathTypes").ThreadRuntimePath;
            readonly composer: import("../..").ThreadComposerRuntime;
            getState(): Readonly<{
                threadId: string;
                isDisabled: boolean;
                isRunning: boolean;
                capabilities: Readonly<{
                    switchToBranch: boolean;
                    edit: boolean;
                    reload: boolean;
                    cancel: boolean;
                    unstable_copy: boolean;
                    speech: boolean;
                    attachments: boolean;
                    feedback: boolean;
                }>;
                messages: readonly ThreadMessage[];
                suggestions: readonly import("../..").ThreadSuggestion[];
                extras: unknown;
                speech: Readonly<{
                    messageId: string;
                    status: import("../..").SpeechSynthesisAdapter.Status;
                }> | undefined;
            }>;
            unstable_getCore(): Readonly<{
                getMessageById: (messageId: string) => {
                    parentId: string | null;
                    message: ThreadMessage;
                } | undefined;
                getBranches: (messageId: string) => readonly string[];
                switchToBranch: (branchId: string) => void;
                append: (message: import("../..").AppendMessage) => void;
                startRun: (parentId: string | null) => void;
                cancelRun: () => void;
                addToolResult: (options: import("../..").AddToolResultOptions) => void;
                speak: (messageId: string) => void;
                stopSpeaking: () => void;
                getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
                submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
                getModelConfig: () => ModelConfig;
                composer: import("../../runtimes/core/ComposerRuntimeCore").ThreadComposerRuntimeCore;
                getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
                beginEdit: (messageId: string) => void;
                speech: Readonly<{
                    messageId: string;
                    status: import("../..").SpeechSynthesisAdapter.Status;
                }> | undefined;
                capabilities: Readonly<Readonly<{
                    switchToBranch: boolean;
                    edit: boolean;
                    reload: boolean;
                    cancel: boolean;
                    unstable_copy: boolean;
                    speech: boolean;
                    attachments: boolean;
                    feedback: boolean;
                }>>;
                threadId: string;
                isDisabled: boolean;
                messages: readonly ThreadMessage[];
                suggestions: readonly import("../..").ThreadSuggestion[];
                extras: unknown;
                subscribe: (callback: () => void) => import("../..").Unsubscribe;
                import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
                export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
                unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
            }>;
            append(message: import("../../api/ThreadRuntime").CreateAppendMessage): void;
            startRun(parentId: string | null): void;
            subscribe(callback: () => void): import("../..").Unsubscribe;
            cancelRun(): void;
            getModelConfig(): ModelConfig;
            export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
            import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
            getMesssageByIndex(idx: number): import("../..").MessageRuntime;
            getMesssageById(messageId: string): import("../..").MessageRuntime;
            stopSpeaking: () => void;
            unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
            capabilities: Readonly<Readonly<{
                switchToBranch: boolean;
                edit: boolean;
                reload: boolean;
                cancel: boolean;
                unstable_copy: boolean;
                speech: boolean;
                attachments: boolean;
                feedback: boolean;
            }>>;
            threadId: string;
            isDisabled: boolean;
            isRunning: boolean;
            messages: readonly ThreadMessage[];
            suggestions: readonly import("../..").ThreadSuggestion[];
            speech: Readonly<{
                messageId: string;
                status: import("../..").SpeechSynthesisAdapter.Status;
            }> | undefined;
            extras: unknown;
            getBranches: (messageId: string) => readonly string[];
            switchToBranch: (branchId: string) => void;
            addToolResult: (options: import("../..").AddToolResultOptions) => void;
            speak: (messageId: string) => void;
            getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
            submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
            getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
            beginEdit: (messageId: string) => void;
        }>>;
        (options: {
            optional: true;
        }): ReadonlyStore<Readonly<{
            readonly path: import("../../api/RuntimePathTypes").ThreadRuntimePath;
            readonly composer: import("../..").ThreadComposerRuntime;
            getState(): Readonly<{
                threadId: string;
                isDisabled: boolean;
                isRunning: boolean;
                capabilities: Readonly<{
                    switchToBranch: boolean;
                    edit: boolean;
                    reload: boolean;
                    cancel: boolean;
                    unstable_copy: boolean;
                    speech: boolean;
                    attachments: boolean;
                    feedback: boolean;
                }>;
                messages: readonly ThreadMessage[];
                suggestions: readonly import("../..").ThreadSuggestion[];
                extras: unknown;
                speech: Readonly<{
                    messageId: string;
                    status: import("../..").SpeechSynthesisAdapter.Status;
                }> | undefined;
            }>;
            unstable_getCore(): Readonly<{
                getMessageById: (messageId: string) => {
                    parentId: string | null;
                    message: ThreadMessage;
                } | undefined;
                getBranches: (messageId: string) => readonly string[];
                switchToBranch: (branchId: string) => void;
                append: (message: import("../..").AppendMessage) => void;
                startRun: (parentId: string | null) => void;
                cancelRun: () => void;
                addToolResult: (options: import("../..").AddToolResultOptions) => void;
                speak: (messageId: string) => void;
                stopSpeaking: () => void;
                getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
                submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
                getModelConfig: () => ModelConfig;
                composer: import("../../runtimes/core/ComposerRuntimeCore").ThreadComposerRuntimeCore;
                getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
                beginEdit: (messageId: string) => void;
                speech: Readonly<{
                    messageId: string;
                    status: import("../..").SpeechSynthesisAdapter.Status;
                }> | undefined;
                capabilities: Readonly<Readonly<{
                    switchToBranch: boolean;
                    edit: boolean;
                    reload: boolean;
                    cancel: boolean;
                    unstable_copy: boolean;
                    speech: boolean;
                    attachments: boolean;
                    feedback: boolean;
                }>>;
                threadId: string;
                isDisabled: boolean;
                messages: readonly ThreadMessage[];
                suggestions: readonly import("../..").ThreadSuggestion[];
                extras: unknown;
                subscribe: (callback: () => void) => import("../..").Unsubscribe;
                import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
                export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
                unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
            }>;
            append(message: import("../../api/ThreadRuntime").CreateAppendMessage): void;
            startRun(parentId: string | null): void;
            subscribe(callback: () => void): import("../..").Unsubscribe;
            cancelRun(): void;
            getModelConfig(): ModelConfig;
            export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
            import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
            getMesssageByIndex(idx: number): import("../..").MessageRuntime;
            getMesssageById(messageId: string): import("../..").MessageRuntime;
            stopSpeaking: () => void;
            unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
            capabilities: Readonly<Readonly<{
                switchToBranch: boolean;
                edit: boolean;
                reload: boolean;
                cancel: boolean;
                unstable_copy: boolean;
                speech: boolean;
                attachments: boolean;
                feedback: boolean;
            }>>;
            threadId: string;
            isDisabled: boolean;
            isRunning: boolean;
            messages: readonly ThreadMessage[];
            suggestions: readonly import("../..").ThreadSuggestion[];
            speech: Readonly<{
                messageId: string;
                status: import("../..").SpeechSynthesisAdapter.Status;
            }> | undefined;
            extras: unknown;
            getBranches: (messageId: string) => readonly string[];
            switchToBranch: (branchId: string) => void;
            addToolResult: (options: import("../..").AddToolResultOptions) => void;
            speak: (messageId: string) => void;
            getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
            submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
            getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
            beginEdit: (messageId: string) => void;
        }>> | null;
    };
};
/**
 * @deprecated Use `useThreadRuntime` instead. This will be removed in 0.6.0.
 */
export declare const useThreadActionsStore: {
    (): ReadonlyStore<Readonly<{
        readonly path: import("../../api/RuntimePathTypes").ThreadRuntimePath;
        readonly composer: import("../..").ThreadComposerRuntime;
        getState(): Readonly<{
            threadId: string;
            isDisabled: boolean;
            isRunning: boolean;
            capabilities: Readonly<{
                switchToBranch: boolean;
                edit: boolean;
                reload: boolean;
                cancel: boolean;
                unstable_copy: boolean;
                speech: boolean;
                attachments: boolean;
                feedback: boolean;
            }>;
            messages: readonly ThreadMessage[];
            suggestions: readonly import("../..").ThreadSuggestion[];
            extras: unknown;
            speech: Readonly<{
                messageId: string;
                status: import("../..").SpeechSynthesisAdapter.Status;
            }> | undefined;
        }>;
        unstable_getCore(): Readonly<{
            getMessageById: (messageId: string) => {
                parentId: string | null;
                message: ThreadMessage;
            } | undefined;
            getBranches: (messageId: string) => readonly string[];
            switchToBranch: (branchId: string) => void;
            append: (message: import("../..").AppendMessage) => void;
            startRun: (parentId: string | null) => void;
            cancelRun: () => void;
            addToolResult: (options: import("../..").AddToolResultOptions) => void;
            speak: (messageId: string) => void;
            stopSpeaking: () => void;
            getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
            submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
            getModelConfig: () => ModelConfig;
            composer: import("../../runtimes/core/ComposerRuntimeCore").ThreadComposerRuntimeCore;
            getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
            beginEdit: (messageId: string) => void;
            speech: Readonly<{
                messageId: string;
                status: import("../..").SpeechSynthesisAdapter.Status;
            }> | undefined;
            capabilities: Readonly<Readonly<{
                switchToBranch: boolean;
                edit: boolean;
                reload: boolean;
                cancel: boolean;
                unstable_copy: boolean;
                speech: boolean;
                attachments: boolean;
                feedback: boolean;
            }>>;
            threadId: string;
            isDisabled: boolean;
            messages: readonly ThreadMessage[];
            suggestions: readonly import("../..").ThreadSuggestion[];
            extras: unknown;
            subscribe: (callback: () => void) => import("../..").Unsubscribe;
            import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
            export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
            unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
        }>;
        append(message: import("../../api/ThreadRuntime").CreateAppendMessage): void;
        startRun(parentId: string | null): void;
        subscribe(callback: () => void): import("../..").Unsubscribe;
        cancelRun(): void;
        getModelConfig(): ModelConfig;
        export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
        import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
        getMesssageByIndex(idx: number): import("../..").MessageRuntime;
        getMesssageById(messageId: string): import("../..").MessageRuntime;
        stopSpeaking: () => void;
        unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
        capabilities: Readonly<Readonly<{
            switchToBranch: boolean;
            edit: boolean;
            reload: boolean;
            cancel: boolean;
            unstable_copy: boolean;
            speech: boolean;
            attachments: boolean;
            feedback: boolean;
        }>>;
        threadId: string;
        isDisabled: boolean;
        isRunning: boolean;
        messages: readonly ThreadMessage[];
        suggestions: readonly import("../..").ThreadSuggestion[];
        speech: Readonly<{
            messageId: string;
            status: import("../..").SpeechSynthesisAdapter.Status;
        }> | undefined;
        extras: unknown;
        getBranches: (messageId: string) => readonly string[];
        switchToBranch: (branchId: string) => void;
        addToolResult: (options: import("../..").AddToolResultOptions) => void;
        speak: (messageId: string) => void;
        getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
        submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
        getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
        beginEdit: (messageId: string) => void;
    }>>;
    (options: {
        optional: true;
    }): ReadonlyStore<Readonly<{
        readonly path: import("../../api/RuntimePathTypes").ThreadRuntimePath;
        readonly composer: import("../..").ThreadComposerRuntime;
        getState(): Readonly<{
            threadId: string;
            isDisabled: boolean;
            isRunning: boolean;
            capabilities: Readonly<{
                switchToBranch: boolean;
                edit: boolean;
                reload: boolean;
                cancel: boolean;
                unstable_copy: boolean;
                speech: boolean;
                attachments: boolean;
                feedback: boolean;
            }>;
            messages: readonly ThreadMessage[];
            suggestions: readonly import("../..").ThreadSuggestion[];
            extras: unknown;
            speech: Readonly<{
                messageId: string;
                status: import("../..").SpeechSynthesisAdapter.Status;
            }> | undefined;
        }>;
        unstable_getCore(): Readonly<{
            getMessageById: (messageId: string) => {
                parentId: string | null;
                message: ThreadMessage;
            } | undefined;
            getBranches: (messageId: string) => readonly string[];
            switchToBranch: (branchId: string) => void;
            append: (message: import("../..").AppendMessage) => void;
            startRun: (parentId: string | null) => void;
            cancelRun: () => void;
            addToolResult: (options: import("../..").AddToolResultOptions) => void;
            speak: (messageId: string) => void;
            stopSpeaking: () => void;
            getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
            submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
            getModelConfig: () => ModelConfig;
            composer: import("../../runtimes/core/ComposerRuntimeCore").ThreadComposerRuntimeCore;
            getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
            beginEdit: (messageId: string) => void;
            speech: Readonly<{
                messageId: string;
                status: import("../..").SpeechSynthesisAdapter.Status;
            }> | undefined;
            capabilities: Readonly<Readonly<{
                switchToBranch: boolean;
                edit: boolean;
                reload: boolean;
                cancel: boolean;
                unstable_copy: boolean;
                speech: boolean;
                attachments: boolean;
                feedback: boolean;
            }>>;
            threadId: string;
            isDisabled: boolean;
            messages: readonly ThreadMessage[];
            suggestions: readonly import("../..").ThreadSuggestion[];
            extras: unknown;
            subscribe: (callback: () => void) => import("../..").Unsubscribe;
            import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
            export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
            unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
        }>;
        append(message: import("../../api/ThreadRuntime").CreateAppendMessage): void;
        startRun(parentId: string | null): void;
        subscribe(callback: () => void): import("../..").Unsubscribe;
        cancelRun(): void;
        getModelConfig(): ModelConfig;
        export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
        import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
        getMesssageByIndex(idx: number): import("../..").MessageRuntime;
        getMesssageById(messageId: string): import("../..").MessageRuntime;
        stopSpeaking: () => void;
        unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
        capabilities: Readonly<Readonly<{
            switchToBranch: boolean;
            edit: boolean;
            reload: boolean;
            cancel: boolean;
            unstable_copy: boolean;
            speech: boolean;
            attachments: boolean;
            feedback: boolean;
        }>>;
        threadId: string;
        isDisabled: boolean;
        isRunning: boolean;
        messages: readonly ThreadMessage[];
        suggestions: readonly import("../..").ThreadSuggestion[];
        speech: Readonly<{
            messageId: string;
            status: import("../..").SpeechSynthesisAdapter.Status;
        }> | undefined;
        extras: unknown;
        getBranches: (messageId: string) => readonly string[];
        switchToBranch: (branchId: string) => void;
        addToolResult: (options: import("../..").AddToolResultOptions) => void;
        speak: (messageId: string) => void;
        getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
        submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
        getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
        beginEdit: (messageId: string) => void;
    }>> | null;
};
/**
 * @deprecated Use `useThreadRuntime` instead. This will be removed in 0.6.0.
 */
export declare const useThreadActions: {
    (): Readonly<{
        readonly path: import("../../api/RuntimePathTypes").ThreadRuntimePath;
        readonly composer: import("../..").ThreadComposerRuntime;
        getState(): Readonly<{
            threadId: string;
            isDisabled: boolean;
            isRunning: boolean;
            capabilities: Readonly<{
                switchToBranch: boolean;
                edit: boolean;
                reload: boolean;
                cancel: boolean;
                unstable_copy: boolean;
                speech: boolean;
                attachments: boolean;
                feedback: boolean;
            }>;
            messages: readonly ThreadMessage[];
            suggestions: readonly import("../..").ThreadSuggestion[];
            extras: unknown;
            speech: Readonly<{
                messageId: string;
                status: import("../..").SpeechSynthesisAdapter.Status;
            }> | undefined;
        }>;
        unstable_getCore(): Readonly<{
            getMessageById: (messageId: string) => {
                parentId: string | null;
                message: ThreadMessage;
            } | undefined;
            getBranches: (messageId: string) => readonly string[];
            switchToBranch: (branchId: string) => void;
            append: (message: import("../..").AppendMessage) => void;
            startRun: (parentId: string | null) => void;
            cancelRun: () => void;
            addToolResult: (options: import("../..").AddToolResultOptions) => void;
            speak: (messageId: string) => void;
            stopSpeaking: () => void;
            getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
            submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
            getModelConfig: () => ModelConfig;
            composer: import("../../runtimes/core/ComposerRuntimeCore").ThreadComposerRuntimeCore;
            getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
            beginEdit: (messageId: string) => void;
            speech: Readonly<{
                messageId: string;
                status: import("../..").SpeechSynthesisAdapter.Status;
            }> | undefined;
            capabilities: Readonly<Readonly<{
                switchToBranch: boolean;
                edit: boolean;
                reload: boolean;
                cancel: boolean;
                unstable_copy: boolean;
                speech: boolean;
                attachments: boolean;
                feedback: boolean;
            }>>;
            threadId: string;
            isDisabled: boolean;
            messages: readonly ThreadMessage[];
            suggestions: readonly import("../..").ThreadSuggestion[];
            extras: unknown;
            subscribe: (callback: () => void) => import("../..").Unsubscribe;
            import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
            export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
            unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
        }>;
        append(message: import("../../api/ThreadRuntime").CreateAppendMessage): void;
        startRun(parentId: string | null): void;
        subscribe(callback: () => void): import("../..").Unsubscribe;
        cancelRun(): void;
        getModelConfig(): ModelConfig;
        export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
        import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
        getMesssageByIndex(idx: number): import("../..").MessageRuntime;
        getMesssageById(messageId: string): import("../..").MessageRuntime;
        stopSpeaking: () => void;
        unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
        capabilities: Readonly<Readonly<{
            switchToBranch: boolean;
            edit: boolean;
            reload: boolean;
            cancel: boolean;
            unstable_copy: boolean;
            speech: boolean;
            attachments: boolean;
            feedback: boolean;
        }>>;
        threadId: string;
        isDisabled: boolean;
        isRunning: boolean;
        messages: readonly ThreadMessage[];
        suggestions: readonly import("../..").ThreadSuggestion[];
        speech: Readonly<{
            messageId: string;
            status: import("../..").SpeechSynthesisAdapter.Status;
        }> | undefined;
        extras: unknown;
        getBranches: (messageId: string) => readonly string[];
        switchToBranch: (branchId: string) => void;
        addToolResult: (options: import("../..").AddToolResultOptions) => void;
        speak: (messageId: string) => void;
        getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
        submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
        getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
        beginEdit: (messageId: string) => void;
    }>;
    <TSelected>(selector: (state: Readonly<{
        readonly path: import("../../api/RuntimePathTypes").ThreadRuntimePath;
        readonly composer: import("../..").ThreadComposerRuntime;
        getState(): Readonly<{
            threadId: string;
            isDisabled: boolean;
            isRunning: boolean;
            capabilities: Readonly<{
                switchToBranch: boolean;
                edit: boolean;
                reload: boolean;
                cancel: boolean;
                unstable_copy: boolean;
                speech: boolean;
                attachments: boolean;
                feedback: boolean;
            }>;
            messages: readonly ThreadMessage[];
            suggestions: readonly import("../..").ThreadSuggestion[];
            extras: unknown;
            speech: Readonly<{
                messageId: string;
                status: import("../..").SpeechSynthesisAdapter.Status;
            }> | undefined;
        }>;
        unstable_getCore(): Readonly<{
            getMessageById: (messageId: string) => {
                parentId: string | null;
                message: ThreadMessage;
            } | undefined;
            getBranches: (messageId: string) => readonly string[];
            switchToBranch: (branchId: string) => void;
            append: (message: import("../..").AppendMessage) => void;
            startRun: (parentId: string | null) => void;
            cancelRun: () => void;
            addToolResult: (options: import("../..").AddToolResultOptions) => void;
            speak: (messageId: string) => void;
            stopSpeaking: () => void;
            getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
            submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
            getModelConfig: () => ModelConfig;
            composer: import("../../runtimes/core/ComposerRuntimeCore").ThreadComposerRuntimeCore;
            getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
            beginEdit: (messageId: string) => void;
            speech: Readonly<{
                messageId: string;
                status: import("../..").SpeechSynthesisAdapter.Status;
            }> | undefined;
            capabilities: Readonly<Readonly<{
                switchToBranch: boolean;
                edit: boolean;
                reload: boolean;
                cancel: boolean;
                unstable_copy: boolean;
                speech: boolean;
                attachments: boolean;
                feedback: boolean;
            }>>;
            threadId: string;
            isDisabled: boolean;
            messages: readonly ThreadMessage[];
            suggestions: readonly import("../..").ThreadSuggestion[];
            extras: unknown;
            subscribe: (callback: () => void) => import("../..").Unsubscribe;
            import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
            export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
            unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
        }>;
        append(message: import("../../api/ThreadRuntime").CreateAppendMessage): void;
        startRun(parentId: string | null): void;
        subscribe(callback: () => void): import("../..").Unsubscribe;
        cancelRun(): void;
        getModelConfig(): ModelConfig;
        export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
        import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
        getMesssageByIndex(idx: number): import("../..").MessageRuntime;
        getMesssageById(messageId: string): import("../..").MessageRuntime;
        stopSpeaking: () => void;
        unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
        capabilities: Readonly<Readonly<{
            switchToBranch: boolean;
            edit: boolean;
            reload: boolean;
            cancel: boolean;
            unstable_copy: boolean;
            speech: boolean;
            attachments: boolean;
            feedback: boolean;
        }>>;
        threadId: string;
        isDisabled: boolean;
        isRunning: boolean;
        messages: readonly ThreadMessage[];
        suggestions: readonly import("../..").ThreadSuggestion[];
        speech: Readonly<{
            messageId: string;
            status: import("../..").SpeechSynthesisAdapter.Status;
        }> | undefined;
        extras: unknown;
        getBranches: (messageId: string) => readonly string[];
        switchToBranch: (branchId: string) => void;
        addToolResult: (options: import("../..").AddToolResultOptions) => void;
        speak: (messageId: string) => void;
        getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
        submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
        getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
        beginEdit: (messageId: string) => void;
    }>) => TSelected): TSelected;
    (options: {
        optional: true;
    }): Readonly<{
        readonly path: import("../../api/RuntimePathTypes").ThreadRuntimePath;
        readonly composer: import("../..").ThreadComposerRuntime;
        getState(): Readonly<{
            threadId: string;
            isDisabled: boolean;
            isRunning: boolean;
            capabilities: Readonly<{
                switchToBranch: boolean;
                edit: boolean;
                reload: boolean;
                cancel: boolean;
                unstable_copy: boolean;
                speech: boolean;
                attachments: boolean;
                feedback: boolean;
            }>;
            messages: readonly ThreadMessage[];
            suggestions: readonly import("../..").ThreadSuggestion[];
            extras: unknown;
            speech: Readonly<{
                messageId: string;
                status: import("../..").SpeechSynthesisAdapter.Status;
            }> | undefined;
        }>;
        unstable_getCore(): Readonly<{
            getMessageById: (messageId: string) => {
                parentId: string | null;
                message: ThreadMessage;
            } | undefined;
            getBranches: (messageId: string) => readonly string[];
            switchToBranch: (branchId: string) => void;
            append: (message: import("../..").AppendMessage) => void;
            startRun: (parentId: string | null) => void;
            cancelRun: () => void;
            addToolResult: (options: import("../..").AddToolResultOptions) => void;
            speak: (messageId: string) => void;
            stopSpeaking: () => void;
            getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
            submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
            getModelConfig: () => ModelConfig;
            composer: import("../../runtimes/core/ComposerRuntimeCore").ThreadComposerRuntimeCore;
            getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
            beginEdit: (messageId: string) => void;
            speech: Readonly<{
                messageId: string;
                status: import("../..").SpeechSynthesisAdapter.Status;
            }> | undefined;
            capabilities: Readonly<Readonly<{
                switchToBranch: boolean;
                edit: boolean;
                reload: boolean;
                cancel: boolean;
                unstable_copy: boolean;
                speech: boolean;
                attachments: boolean;
                feedback: boolean;
            }>>;
            threadId: string;
            isDisabled: boolean;
            messages: readonly ThreadMessage[];
            suggestions: readonly import("../..").ThreadSuggestion[];
            extras: unknown;
            subscribe: (callback: () => void) => import("../..").Unsubscribe;
            import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
            export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
            unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
        }>;
        append(message: import("../../api/ThreadRuntime").CreateAppendMessage): void;
        startRun(parentId: string | null): void;
        subscribe(callback: () => void): import("../..").Unsubscribe;
        cancelRun(): void;
        getModelConfig(): ModelConfig;
        export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
        import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
        getMesssageByIndex(idx: number): import("../..").MessageRuntime;
        getMesssageById(messageId: string): import("../..").MessageRuntime;
        stopSpeaking: () => void;
        unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
        capabilities: Readonly<Readonly<{
            switchToBranch: boolean;
            edit: boolean;
            reload: boolean;
            cancel: boolean;
            unstable_copy: boolean;
            speech: boolean;
            attachments: boolean;
            feedback: boolean;
        }>>;
        threadId: string;
        isDisabled: boolean;
        isRunning: boolean;
        messages: readonly ThreadMessage[];
        suggestions: readonly import("../..").ThreadSuggestion[];
        speech: Readonly<{
            messageId: string;
            status: import("../..").SpeechSynthesisAdapter.Status;
        }> | undefined;
        extras: unknown;
        getBranches: (messageId: string) => readonly string[];
        switchToBranch: (branchId: string) => void;
        addToolResult: (options: import("../..").AddToolResultOptions) => void;
        speak: (messageId: string) => void;
        getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
        submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
        getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
        beginEdit: (messageId: string) => void;
    }> | null;
    <TSelected>(options: {
        optional: true;
        selector?: (state: Readonly<{
            readonly path: import("../../api/RuntimePathTypes").ThreadRuntimePath;
            readonly composer: import("../..").ThreadComposerRuntime;
            getState(): Readonly<{
                threadId: string;
                isDisabled: boolean;
                isRunning: boolean;
                capabilities: Readonly<{
                    switchToBranch: boolean;
                    edit: boolean;
                    reload: boolean;
                    cancel: boolean;
                    unstable_copy: boolean;
                    speech: boolean;
                    attachments: boolean;
                    feedback: boolean;
                }>;
                messages: readonly ThreadMessage[];
                suggestions: readonly import("../..").ThreadSuggestion[];
                extras: unknown;
                speech: Readonly<{
                    messageId: string;
                    status: import("../..").SpeechSynthesisAdapter.Status;
                }> | undefined;
            }>;
            unstable_getCore(): Readonly<{
                getMessageById: (messageId: string) => {
                    parentId: string | null;
                    message: ThreadMessage;
                } | undefined;
                getBranches: (messageId: string) => readonly string[];
                switchToBranch: (branchId: string) => void;
                append: (message: import("../..").AppendMessage) => void;
                startRun: (parentId: string | null) => void;
                cancelRun: () => void;
                addToolResult: (options: import("../..").AddToolResultOptions) => void;
                speak: (messageId: string) => void;
                stopSpeaking: () => void;
                getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
                submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
                getModelConfig: () => ModelConfig;
                composer: import("../../runtimes/core/ComposerRuntimeCore").ThreadComposerRuntimeCore;
                getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
                beginEdit: (messageId: string) => void;
                speech: Readonly<{
                    messageId: string;
                    status: import("../..").SpeechSynthesisAdapter.Status;
                }> | undefined;
                capabilities: Readonly<Readonly<{
                    switchToBranch: boolean;
                    edit: boolean;
                    reload: boolean;
                    cancel: boolean;
                    unstable_copy: boolean;
                    speech: boolean;
                    attachments: boolean;
                    feedback: boolean;
                }>>;
                threadId: string;
                isDisabled: boolean;
                messages: readonly ThreadMessage[];
                suggestions: readonly import("../..").ThreadSuggestion[];
                extras: unknown;
                subscribe: (callback: () => void) => import("../..").Unsubscribe;
                import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
                export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
                unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
            }>;
            append(message: import("../../api/ThreadRuntime").CreateAppendMessage): void;
            startRun(parentId: string | null): void;
            subscribe(callback: () => void): import("../..").Unsubscribe;
            cancelRun(): void;
            getModelConfig(): ModelConfig;
            export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
            import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
            getMesssageByIndex(idx: number): import("../..").MessageRuntime;
            getMesssageById(messageId: string): import("../..").MessageRuntime;
            stopSpeaking: () => void;
            unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
            capabilities: Readonly<Readonly<{
                switchToBranch: boolean;
                edit: boolean;
                reload: boolean;
                cancel: boolean;
                unstable_copy: boolean;
                speech: boolean;
                attachments: boolean;
                feedback: boolean;
            }>>;
            threadId: string;
            isDisabled: boolean;
            isRunning: boolean;
            messages: readonly ThreadMessage[];
            suggestions: readonly import("../..").ThreadSuggestion[];
            speech: Readonly<{
                messageId: string;
                status: import("../..").SpeechSynthesisAdapter.Status;
            }> | undefined;
            extras: unknown;
            getBranches: (messageId: string) => readonly string[];
            switchToBranch: (branchId: string) => void;
            addToolResult: (options: import("../..").AddToolResultOptions) => void;
            speak: (messageId: string) => void;
            getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
            submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
            getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
            beginEdit: (messageId: string) => void;
        }>) => TSelected;
    }): TSelected | null;
};
/**
 * @deprecated Use `useThreadRuntime` instead. This will be removed in 0.6.0.
 */
export declare const useThreadRuntimeStore: {
    (): ReadonlyStore<Readonly<{
        readonly path: import("../../api/RuntimePathTypes").ThreadRuntimePath;
        readonly composer: import("../..").ThreadComposerRuntime;
        getState(): Readonly<{
            threadId: string;
            isDisabled: boolean;
            isRunning: boolean;
            capabilities: Readonly<{
                switchToBranch: boolean;
                edit: boolean;
                reload: boolean;
                cancel: boolean;
                unstable_copy: boolean;
                speech: boolean;
                attachments: boolean;
                feedback: boolean;
            }>;
            messages: readonly ThreadMessage[];
            suggestions: readonly import("../..").ThreadSuggestion[];
            extras: unknown;
            speech: Readonly<{
                messageId: string;
                status: import("../..").SpeechSynthesisAdapter.Status;
            }> | undefined;
        }>;
        unstable_getCore(): Readonly<{
            getMessageById: (messageId: string) => {
                parentId: string | null;
                message: ThreadMessage;
            } | undefined;
            getBranches: (messageId: string) => readonly string[];
            switchToBranch: (branchId: string) => void;
            append: (message: import("../..").AppendMessage) => void;
            startRun: (parentId: string | null) => void;
            cancelRun: () => void;
            addToolResult: (options: import("../..").AddToolResultOptions) => void;
            speak: (messageId: string) => void;
            stopSpeaking: () => void;
            getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
            submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
            getModelConfig: () => ModelConfig;
            composer: import("../../runtimes/core/ComposerRuntimeCore").ThreadComposerRuntimeCore;
            getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
            beginEdit: (messageId: string) => void;
            speech: Readonly<{
                messageId: string;
                status: import("../..").SpeechSynthesisAdapter.Status;
            }> | undefined;
            capabilities: Readonly<Readonly<{
                switchToBranch: boolean;
                edit: boolean;
                reload: boolean;
                cancel: boolean;
                unstable_copy: boolean;
                speech: boolean;
                attachments: boolean;
                feedback: boolean;
            }>>;
            threadId: string;
            isDisabled: boolean;
            messages: readonly ThreadMessage[];
            suggestions: readonly import("../..").ThreadSuggestion[];
            extras: unknown;
            subscribe: (callback: () => void) => import("../..").Unsubscribe;
            import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
            export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
            unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
        }>;
        append(message: import("../../api/ThreadRuntime").CreateAppendMessage): void;
        startRun(parentId: string | null): void;
        subscribe(callback: () => void): import("../..").Unsubscribe;
        cancelRun(): void;
        getModelConfig(): ModelConfig;
        export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
        import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
        getMesssageByIndex(idx: number): import("../..").MessageRuntime;
        getMesssageById(messageId: string): import("../..").MessageRuntime;
        stopSpeaking: () => void;
        unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
        capabilities: Readonly<Readonly<{
            switchToBranch: boolean;
            edit: boolean;
            reload: boolean;
            cancel: boolean;
            unstable_copy: boolean;
            speech: boolean;
            attachments: boolean;
            feedback: boolean;
        }>>;
        threadId: string;
        isDisabled: boolean;
        isRunning: boolean;
        messages: readonly ThreadMessage[];
        suggestions: readonly import("../..").ThreadSuggestion[];
        speech: Readonly<{
            messageId: string;
            status: import("../..").SpeechSynthesisAdapter.Status;
        }> | undefined;
        extras: unknown;
        getBranches: (messageId: string) => readonly string[];
        switchToBranch: (branchId: string) => void;
        addToolResult: (options: import("../..").AddToolResultOptions) => void;
        speak: (messageId: string) => void;
        getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
        submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
        getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
        beginEdit: (messageId: string) => void;
    }>>;
    (options: {
        optional: true;
    }): ReadonlyStore<Readonly<{
        readonly path: import("../../api/RuntimePathTypes").ThreadRuntimePath;
        readonly composer: import("../..").ThreadComposerRuntime;
        getState(): Readonly<{
            threadId: string;
            isDisabled: boolean;
            isRunning: boolean;
            capabilities: Readonly<{
                switchToBranch: boolean;
                edit: boolean;
                reload: boolean;
                cancel: boolean;
                unstable_copy: boolean;
                speech: boolean;
                attachments: boolean;
                feedback: boolean;
            }>;
            messages: readonly ThreadMessage[];
            suggestions: readonly import("../..").ThreadSuggestion[];
            extras: unknown;
            speech: Readonly<{
                messageId: string;
                status: import("../..").SpeechSynthesisAdapter.Status;
            }> | undefined;
        }>;
        unstable_getCore(): Readonly<{
            getMessageById: (messageId: string) => {
                parentId: string | null;
                message: ThreadMessage;
            } | undefined;
            getBranches: (messageId: string) => readonly string[];
            switchToBranch: (branchId: string) => void;
            append: (message: import("../..").AppendMessage) => void;
            startRun: (parentId: string | null) => void;
            cancelRun: () => void;
            addToolResult: (options: import("../..").AddToolResultOptions) => void;
            speak: (messageId: string) => void;
            stopSpeaking: () => void;
            getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
            submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
            getModelConfig: () => ModelConfig;
            composer: import("../../runtimes/core/ComposerRuntimeCore").ThreadComposerRuntimeCore;
            getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
            beginEdit: (messageId: string) => void;
            speech: Readonly<{
                messageId: string;
                status: import("../..").SpeechSynthesisAdapter.Status;
            }> | undefined;
            capabilities: Readonly<Readonly<{
                switchToBranch: boolean;
                edit: boolean;
                reload: boolean;
                cancel: boolean;
                unstable_copy: boolean;
                speech: boolean;
                attachments: boolean;
                feedback: boolean;
            }>>;
            threadId: string;
            isDisabled: boolean;
            messages: readonly ThreadMessage[];
            suggestions: readonly import("../..").ThreadSuggestion[];
            extras: unknown;
            subscribe: (callback: () => void) => import("../..").Unsubscribe;
            import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
            export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
            unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
        }>;
        append(message: import("../../api/ThreadRuntime").CreateAppendMessage): void;
        startRun(parentId: string | null): void;
        subscribe(callback: () => void): import("../..").Unsubscribe;
        cancelRun(): void;
        getModelConfig(): ModelConfig;
        export(): import("../../runtimes/utils/MessageRepository").ExportedMessageRepository;
        import(repository: import("../../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
        getMesssageByIndex(idx: number): import("../..").MessageRuntime;
        getMesssageById(messageId: string): import("../..").MessageRuntime;
        stopSpeaking: () => void;
        unstable_on(event: import("../../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
        capabilities: Readonly<Readonly<{
            switchToBranch: boolean;
            edit: boolean;
            reload: boolean;
            cancel: boolean;
            unstable_copy: boolean;
            speech: boolean;
            attachments: boolean;
            feedback: boolean;
        }>>;
        threadId: string;
        isDisabled: boolean;
        isRunning: boolean;
        messages: readonly ThreadMessage[];
        suggestions: readonly import("../..").ThreadSuggestion[];
        speech: Readonly<{
            messageId: string;
            status: import("../..").SpeechSynthesisAdapter.Status;
        }> | undefined;
        extras: unknown;
        getBranches: (messageId: string) => readonly string[];
        switchToBranch: (branchId: string) => void;
        addToolResult: (options: import("../..").AddToolResultOptions) => void;
        speak: (messageId: string) => void;
        getSubmittedFeedback: (messageId: string) => import("../../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
        submitFeedback: (feedback: import("../..").SubmitFeedbackOptions) => void;
        getEditComposer: (messageId: string) => import("../../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
        beginEdit: (messageId: string) => void;
    }>> | null;
};
export declare const useThread: {
    (): Readonly<{
        threadId: string;
        isDisabled: boolean;
        isRunning: boolean;
        capabilities: Readonly<{
            switchToBranch: boolean;
            edit: boolean;
            reload: boolean;
            cancel: boolean;
            unstable_copy: boolean;
            speech: boolean;
            attachments: boolean;
            feedback: boolean;
        }>;
        messages: readonly ThreadMessage[];
        suggestions: readonly import("../..").ThreadSuggestion[];
        extras: unknown;
        speech: Readonly<{
            messageId: string;
            status: import("../..").SpeechSynthesisAdapter.Status;
        }> | undefined;
    }>;
    <TSelected>(selector: (state: Readonly<{
        threadId: string;
        isDisabled: boolean;
        isRunning: boolean;
        capabilities: Readonly<{
            switchToBranch: boolean;
            edit: boolean;
            reload: boolean;
            cancel: boolean;
            unstable_copy: boolean;
            speech: boolean;
            attachments: boolean;
            feedback: boolean;
        }>;
        messages: readonly ThreadMessage[];
        suggestions: readonly import("../..").ThreadSuggestion[];
        extras: unknown;
        speech: Readonly<{
            messageId: string;
            status: import("../..").SpeechSynthesisAdapter.Status;
        }> | undefined;
    }>) => TSelected): TSelected;
    (options: {
        optional: true;
    }): Readonly<{
        threadId: string;
        isDisabled: boolean;
        isRunning: boolean;
        capabilities: Readonly<{
            switchToBranch: boolean;
            edit: boolean;
            reload: boolean;
            cancel: boolean;
            unstable_copy: boolean;
            speech: boolean;
            attachments: boolean;
            feedback: boolean;
        }>;
        messages: readonly ThreadMessage[];
        suggestions: readonly import("../..").ThreadSuggestion[];
        extras: unknown;
        speech: Readonly<{
            messageId: string;
            status: import("../..").SpeechSynthesisAdapter.Status;
        }> | undefined;
    }> | null;
    <TSelected>(options: {
        optional: true;
        selector?: (state: Readonly<{
            threadId: string;
            isDisabled: boolean;
            isRunning: boolean;
            capabilities: Readonly<{
                switchToBranch: boolean;
                edit: boolean;
                reload: boolean;
                cancel: boolean;
                unstable_copy: boolean;
                speech: boolean;
                attachments: boolean;
                feedback: boolean;
            }>;
            messages: readonly ThreadMessage[];
            suggestions: readonly import("../..").ThreadSuggestion[];
            extras: unknown;
            speech: Readonly<{
                messageId: string;
                status: import("../..").SpeechSynthesisAdapter.Status;
            }> | undefined;
        }>) => TSelected;
    }): TSelected | null;
}, useThreadStore: {
    (): ReadonlyStore<Readonly<{
        threadId: string;
        isDisabled: boolean;
        isRunning: boolean;
        capabilities: Readonly<{
            switchToBranch: boolean;
            edit: boolean;
            reload: boolean;
            cancel: boolean;
            unstable_copy: boolean;
            speech: boolean;
            attachments: boolean;
            feedback: boolean;
        }>;
        messages: readonly ThreadMessage[];
        suggestions: readonly import("../..").ThreadSuggestion[];
        extras: unknown;
        speech: Readonly<{
            messageId: string;
            status: import("../..").SpeechSynthesisAdapter.Status;
        }> | undefined;
    }>>;
    (options: {
        optional: true;
    }): ReadonlyStore<Readonly<{
        threadId: string;
        isDisabled: boolean;
        isRunning: boolean;
        capabilities: Readonly<{
            switchToBranch: boolean;
            edit: boolean;
            reload: boolean;
            cancel: boolean;
            unstable_copy: boolean;
            speech: boolean;
            attachments: boolean;
            feedback: boolean;
        }>;
        messages: readonly ThreadMessage[];
        suggestions: readonly import("../..").ThreadSuggestion[];
        extras: unknown;
        speech: Readonly<{
            messageId: string;
            status: import("../..").SpeechSynthesisAdapter.Status;
        }> | undefined;
    }>> | null;
};
/**
 * @deprecated Use `useThread().messages` instead. This will be removed in 0.6.0.
 */
export declare const useThreadMessages: {
    (): readonly ThreadMessage[];
    <TSelected>(selector: (state: readonly ThreadMessage[]) => TSelected): TSelected;
    (options: {
        optional: true;
    }): readonly ThreadMessage[] | null;
    <TSelected>(options: {
        optional: true;
        selector?: (state: readonly ThreadMessage[]) => TSelected;
    }): TSelected | null;
};
/**
 * @deprecated Use `useThreadRuntime().getState().messages` instead. This will be removed in 0.6.0.
 */
export declare const useThreadMessagesStore: {
    (): ReadonlyStore<readonly ThreadMessage[]>;
    (options: {
        optional: true;
    }): ReadonlyStore<readonly ThreadMessage[]> | null;
};
export declare const useThreadComposer: {
    (): ThreadComposerState;
    <TSelected>(selector: (state: ThreadComposerState) => TSelected): TSelected;
    (options: {
        optional: true;
    }): ThreadComposerState | null;
    <TSelected>(options: {
        optional: true;
        selector?: (state: ThreadComposerState) => TSelected;
    }): TSelected | null;
}, useThreadComposerStore: {
    (): ReadonlyStore<ThreadComposerState>;
    (options: {
        optional: true;
    }): ReadonlyStore<ThreadComposerState> | null;
};
export declare const useThreadViewport: {
    (): Readonly<{
        isAtBottom: boolean;
        scrollToBottom: () => void;
        onScrollToBottom: (callback: () => void) => import("../..").Unsubscribe;
    }>;
    <TSelected>(selector: (state: Readonly<{
        isAtBottom: boolean;
        scrollToBottom: () => void;
        onScrollToBottom: (callback: () => void) => import("../..").Unsubscribe;
    }>) => TSelected): TSelected;
    (options: {
        optional: true;
    }): Readonly<{
        isAtBottom: boolean;
        scrollToBottom: () => void;
        onScrollToBottom: (callback: () => void) => import("../..").Unsubscribe;
    }> | null;
    <TSelected>(options: {
        optional: true;
        selector?: (state: Readonly<{
            isAtBottom: boolean;
            scrollToBottom: () => void;
            onScrollToBottom: (callback: () => void) => import("../..").Unsubscribe;
        }>) => TSelected;
    }): TSelected | null;
}, useThreadViewportStore: {
    (): ReadonlyStore<Readonly<{
        isAtBottom: boolean;
        scrollToBottom: () => void;
        onScrollToBottom: (callback: () => void) => import("../..").Unsubscribe;
    }>>;
    (options: {
        optional: true;
    }): ReadonlyStore<Readonly<{
        isAtBottom: boolean;
        scrollToBottom: () => void;
        onScrollToBottom: (callback: () => void) => import("../..").Unsubscribe;
    }>> | null;
};
export declare function useThreadModelConfig(options?: {
    optional?: false | undefined;
}): ModelConfig;
export declare function useThreadModelConfig(options?: {
    optional?: boolean | undefined;
}): ModelConfig | null;
//# sourceMappingURL=ThreadContext.d.ts.map