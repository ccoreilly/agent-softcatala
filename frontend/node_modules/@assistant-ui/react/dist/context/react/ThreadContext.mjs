"use client";

// src/context/react/ThreadContext.ts
import { createContext, useEffect, useState } from "react";
import { createContextHook } from "./utils/createContextHook.mjs";
import { createContextStoreHook } from "./utils/createContextStoreHook.mjs";
var ThreadContext = createContext(null);
var useThreadContext = createContextHook(
  ThreadContext,
  "AssistantRuntimeProvider"
);
function useThreadRuntime(options) {
  const context = useThreadContext(options);
  if (!context) return null;
  return context.useThreadRuntime();
}
var actions = createContextStoreHook(
  useThreadContext,
  "useThreadActions"
);
var useThreadActionsStore = actions.useThreadActionsStore;
var useThreadActions = actions.useThreadActions;
var useThreadRuntimeStore = useThreadActionsStore;
var { useThread, useThreadStore } = createContextStoreHook(
  useThreadContext,
  "useThread"
);
var messages = createContextStoreHook(useThreadContext, "useThreadMessages");
var useThreadMessages = messages.useThreadMessages;
var useThreadMessagesStore = messages.useThreadMessagesStore;
var {
  useComposer: useThreadComposer,
  useComposerStore: useThreadComposerStore
} = createContextStoreHook(useThreadContext, "useComposer");
var {
  useViewport: useThreadViewport,
  useViewportStore: useThreadViewportStore
} = createContextStoreHook(useThreadContext, "useViewport");
function useThreadModelConfig(options) {
  const [, rerender] = useState({});
  const runtime = useThreadRuntime(options);
  useEffect(() => {
    return runtime?.unstable_on("model-config-update", () => rerender({}));
  }, [runtime]);
  if (!runtime) return null;
  return runtime?.getModelConfig();
}
export {
  ThreadContext,
  actions,
  useThread,
  useThreadActions,
  useThreadActionsStore,
  useThreadComposer,
  useThreadComposerStore,
  useThreadContext,
  useThreadMessages,
  useThreadMessagesStore,
  useThreadModelConfig,
  useThreadRuntime,
  useThreadRuntimeStore,
  useThreadStore,
  useThreadViewport,
  useThreadViewportStore
};
//# sourceMappingURL=ThreadContext.mjs.map