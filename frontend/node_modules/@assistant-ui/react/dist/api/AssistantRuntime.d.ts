import { AssistantRuntimeCore } from "../runtimes/core/AssistantRuntimeCore";
import { ModelConfigProvider } from "../types/ModelConfigTypes";
import { ThreadRuntime, ThreadRuntimeCoreBinding } from "./ThreadRuntime";
import { Unsubscribe } from "../types";
import { ThreadListRuntime, ThreadListRuntimeImpl } from "./ThreadListRuntime";
export type AssistantRuntime = {
    /**
     * The currently selected main thread.
     */
    thread: ThreadRuntime;
    /**
     * The thread manager, to rename, archive and delete threads.
     */
    threadList: ThreadListRuntime;
    /**
     * Switch to a new thread.
     */
    switchToNewThread(): void;
    /**
     * Switch to a thread.
     *
     * @param threadId The thread ID to switch to.
     */
    switchToThread(threadId: string): void;
    /**
     * @deprecated Use `switchToNewThread` instead. This will be removed in 0.6.0.
     */
    switchToThread(threadId: string | null): void;
    /**
     * Register a model config provider. Model config providers are configuration such as system message, temperature, etc. that are set in the frontend.
     *
     * @param provider The model config provider to register.
     */
    registerModelConfigProvider(provider: ModelConfigProvider): Unsubscribe;
    /**
     * @deprecated Thread is now static and never gets updated. This will be removed in 0.6.0.
     */
    subscribe(callback: () => void): Unsubscribe;
};
export declare class AssistantRuntimeImpl implements Omit<AssistantRuntimeCore, "thread" | "threadList">, AssistantRuntime {
    private readonly _core;
    private readonly _thread;
    readonly threadList: ThreadListRuntimeImpl;
    protected constructor(_core: AssistantRuntimeCore, _thread: ThreadRuntime);
    get thread(): Readonly<{
        readonly path: import("./RuntimePathTypes").ThreadRuntimePath;
        readonly composer: import("./ComposerRuntime").ThreadComposerRuntime;
        getState(): import("./ThreadRuntime").ThreadState;
        unstable_getCore(): import("../internal").ThreadRuntimeCore;
        append(message: import("./ThreadRuntime").CreateAppendMessage): void;
        startRun(parentId: string | null): void;
        subscribe(callback: () => void): Unsubscribe;
        cancelRun(): void;
        getModelConfig(): import("..").ModelConfig;
        export(): import("../runtimes/utils/MessageRepository").ExportedMessageRepository;
        import(repository: import("../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
        getMesssageByIndex(idx: number): import("./MessageRuntime").MessageRuntime;
        getMesssageById(messageId: string): import("./MessageRuntime").MessageRuntime;
        stopSpeaking: () => void;
        unstable_on(event: import("../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): Unsubscribe;
        capabilities: Readonly<import("../runtimes/core/ThreadRuntimeCore").RuntimeCapabilities>;
        threadId: string;
        isDisabled: boolean;
        isRunning: boolean;
        messages: readonly import("..").ThreadMessage[];
        suggestions: readonly import("..").ThreadSuggestion[];
        speech: import("../runtimes/core/ThreadRuntimeCore").SpeechState | undefined;
        extras: unknown;
        getBranches: (messageId: string) => readonly string[];
        switchToBranch: (branchId: string) => void;
        addToolResult: (options: import("..").AddToolResultOptions) => void;
        speak: (messageId: string) => void;
        getSubmittedFeedback: (messageId: string) => import("../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
        submitFeedback: (feedback: import("..").SubmitFeedbackOptions) => void;
        getEditComposer: (messageId: string) => import("../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
        beginEdit: (messageId: string) => void;
    }>;
    switchToNewThread(): void;
    switchToThread(threadId: string): void;
    /**
     * @deprecated Use `switchToNewThread` instead. This will be removed in 0.6.0.
     */
    switchToThread(threadId: string | null): void;
    registerModelConfigProvider(provider: ModelConfigProvider): Unsubscribe;
    /**
     * @deprecated Thread is now static and never gets updated. This will be removed in 0.6.0.
     */
    subscribe(): () => void;
    protected static createMainThreadRuntime(_core: AssistantRuntimeCore, CustomThreadRuntime?: new (binding: ThreadRuntimeCoreBinding) => ThreadRuntime): Readonly<{
        readonly path: import("./RuntimePathTypes").ThreadRuntimePath;
        readonly composer: import("./ComposerRuntime").ThreadComposerRuntime;
        getState(): import("./ThreadRuntime").ThreadState;
        unstable_getCore(): import("../internal").ThreadRuntimeCore;
        append(message: import("./ThreadRuntime").CreateAppendMessage): void;
        startRun(parentId: string | null): void;
        subscribe(callback: () => void): Unsubscribe;
        cancelRun(): void;
        getModelConfig(): import("..").ModelConfig;
        export(): import("../runtimes/utils/MessageRepository").ExportedMessageRepository;
        import(repository: import("../runtimes/utils/MessageRepository").ExportedMessageRepository): void;
        getMesssageByIndex(idx: number): import("./MessageRuntime").MessageRuntime;
        getMesssageById(messageId: string): import("./MessageRuntime").MessageRuntime;
        stopSpeaking: () => void;
        unstable_on(event: import("../runtimes/core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): Unsubscribe;
        capabilities: Readonly<import("../runtimes/core/ThreadRuntimeCore").RuntimeCapabilities>;
        threadId: string;
        isDisabled: boolean;
        isRunning: boolean;
        messages: readonly import("..").ThreadMessage[];
        suggestions: readonly import("..").ThreadSuggestion[];
        speech: import("../runtimes/core/ThreadRuntimeCore").SpeechState | undefined;
        extras: unknown;
        getBranches: (messageId: string) => readonly string[];
        switchToBranch: (branchId: string) => void;
        addToolResult: (options: import("..").AddToolResultOptions) => void;
        speak: (messageId: string) => void;
        getSubmittedFeedback: (messageId: string) => import("../runtimes/core/ThreadRuntimeCore").SubmittedFeedback | undefined;
        submitFeedback: (feedback: import("..").SubmitFeedbackOptions) => void;
        getEditComposer: (messageId: string) => import("../runtimes/core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
        beginEdit: (messageId: string) => void;
    }>;
    static create(_core: AssistantRuntimeCore, CustomThreadRuntime?: new (binding: ThreadRuntimeCoreBinding) => ThreadRuntime): AssistantRuntime;
}
//# sourceMappingURL=AssistantRuntime.d.ts.map