"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/api/ThreadRuntime.ts
var ThreadRuntime_exports = {};
__export(ThreadRuntime_exports, {
  ThreadRuntimeImpl: () => ThreadRuntimeImpl,
  getThreadState: () => getThreadState
});
module.exports = __toCommonJS(ThreadRuntime_exports);
var import_MessageRuntime = require("./MessageRuntime.cjs");
var import_NestedSubscriptionSubject = require("./subscribable/NestedSubscriptionSubject.cjs");
var import_ShallowMemoizeSubject = require("./subscribable/ShallowMemoizeSubject.cjs");
var import_ComposerRuntime = require("./ComposerRuntime.cjs");
var import_LazyMemoizeSubject = require("./subscribable/LazyMemoizeSubject.cjs");
var import_SKIP_UPDATE = require("./subscribable/SKIP_UPDATE.cjs");
var toAppendMessage = (messages, message) => {
  if (typeof message === "string") {
    return {
      parentId: messages.at(-1)?.id ?? null,
      role: "user",
      content: [{ type: "text", text: message }],
      attachments: []
    };
  }
  if (message.role && message.parentId && message.attachments) {
    return message;
  }
  return {
    ...message,
    parentId: message.parentId ?? messages.at(-1)?.id ?? null,
    role: message.role ?? "user",
    attachments: message.attachments ?? []
  };
};
var getThreadState = (runtime) => {
  const lastMessage = runtime.messages.at(-1);
  return Object.freeze({
    threadId: runtime.threadId,
    capabilities: runtime.capabilities,
    isDisabled: runtime.isDisabled,
    isRunning: lastMessage?.role !== "assistant" ? false : lastMessage.status.type === "running",
    messages: runtime.messages,
    suggestions: runtime.suggestions,
    extras: runtime.extras,
    speech: runtime.speech
  });
};
var ThreadRuntimeImpl = class {
  get path() {
    return this._threadBinding.path;
  }
  /**
   * @deprecated Use `getState().threadId` instead. This will be removed in 0.6.0.
   */
  get threadId() {
    return this.getState().threadId;
  }
  /**
   * @deprecated Use `getState().isDisabled` instead. This will be removed in 0.6.0.
   */
  get isDisabled() {
    return this.getState().isDisabled;
  }
  /**
   * @deprecated Use `getState().isRunning` instead. This will be removed in 0.6.0.
   */
  get isRunning() {
    return this.getState().isRunning;
  }
  /**
   * @deprecated Use `getState().capabilities` instead. This will be removed in 0.6.0.
   */
  get capabilities() {
    return this.getState().capabilities;
  }
  /**
   * @deprecated Use `getState().extras` instead. This will be removed in 0.6.0.
   */
  get extras() {
    return this._threadBinding.getState().extras;
  }
  /**
   * @deprecated Use `getState().followupSuggestions` instead. This will be removed in 0.6.0.
   */
  get suggestions() {
    return this._threadBinding.getState().suggestions;
  }
  /**
   * @deprecated Use `getState().messages` instead. This will be removed in 0.6.0.
   */
  get messages() {
    return this._threadBinding.getState().messages;
  }
  /**
   * @deprecated Use `getState().speechState` instead. This will be removed in 0.6.0.
   */
  get speech() {
    return this._threadBinding.getState().speech;
  }
  unstable_getCore() {
    return this._threadBinding.getState();
  }
  _threadBinding;
  constructor(threadBinding) {
    const stateBinding = new import_LazyMemoizeSubject.LazyMemoizeSubject({
      path: threadBinding.path,
      getState: () => getThreadState(threadBinding.getState()),
      subscribe: (callback) => threadBinding.subscribe(callback)
    });
    this._threadBinding = {
      path: threadBinding.path,
      getState: () => threadBinding.getState(),
      getStateState: () => stateBinding.getState(),
      outerSubscribe: (callback) => threadBinding.outerSubscribe(callback),
      subscribe: (callback) => threadBinding.subscribe(callback)
    };
    this.composer = new import_ComposerRuntime.ThreadComposerRuntimeImpl(
      new import_NestedSubscriptionSubject.NestedSubscriptionSubject({
        path: {
          ...this.path,
          ref: this.path.ref + `${this.path.ref}.composer`,
          composerSource: "thread"
        },
        getState: () => this._threadBinding.getState().composer,
        subscribe: (callback) => this._threadBinding.subscribe(callback)
      })
    );
  }
  composer;
  getState() {
    return this._threadBinding.getStateState();
  }
  append(message) {
    this._threadBinding.getState().append(
      toAppendMessage(this._threadBinding.getState().messages, message)
    );
  }
  subscribe(callback) {
    return this._threadBinding.subscribe(callback);
  }
  /**
   * @derprecated Use `getMesssageById(id).getState().branchNumber` / `getMesssageById(id).getState().branchCount` instead. This will be removed in 0.6.0.
   */
  getBranches(messageId) {
    return this._threadBinding.getState().getBranches(messageId);
  }
  getModelConfig() {
    return this._threadBinding.getState().getModelConfig();
  }
  // TODO sometimes you want to continue when there is no child message
  startRun(parentId) {
    return this._threadBinding.getState().startRun(parentId);
  }
  cancelRun() {
    this._threadBinding.getState().cancelRun();
  }
  /**
   * @deprecated Use `getMesssageById(id).getContentPartByToolCallId(toolCallId).addToolResult({ result })` instead. This will be removed in 0.6.0.
   */
  addToolResult(options) {
    this._threadBinding.getState().addToolResult(options);
  }
  /**
   * @deprecated Use `getMesssageById(id).switchToBranch({ options })` instead. This will be removed in 0.6.0.
   */
  switchToBranch(branchId) {
    return this._threadBinding.getState().switchToBranch(branchId);
  }
  /**
   * @deprecated Use `getMesssageById(id).speak()` instead. This will be removed in 0.6.0.
   */
  speak(messageId) {
    return this._threadBinding.getState().speak(messageId);
  }
  stopSpeaking() {
    return this._threadBinding.getState().stopSpeaking();
  }
  getSubmittedFeedback(messageId) {
    return this._threadBinding.getState().getSubmittedFeedback(messageId);
  }
  /**
   * @deprecated Use `getMesssageById(id).submitFeedback({ type })` instead. This will be removed in 0.6.0.
   */
  submitFeedback(options) {
    return this._threadBinding.getState().submitFeedback(options);
  }
  /**
   * @deprecated Use `getMesssageById(id).getMessageByIndex(idx).composer` instead. This will be removed in 0.6.0.
   */
  getEditComposer(messageId) {
    return this._threadBinding.getState().getEditComposer(messageId);
  }
  /**
   * @deprecated Use `getMesssageById(id).getMessageByIndex(idx).composer.beginEdit()` instead. This will be removed in 0.6.0.
   */
  beginEdit(messageId) {
    return this._threadBinding.getState().beginEdit(messageId);
  }
  export() {
    return this._threadBinding.getState().export();
  }
  import(data) {
    this._threadBinding.getState().import(data);
  }
  getMesssageByIndex(idx) {
    if (idx < 0) throw new Error("Message index must be >= 0");
    return this._getMessageRuntime(
      {
        ...this.path,
        ref: this.path.ref + `${this.path.ref}.messages[${idx}]`,
        messageSelector: { type: "index", index: idx }
      },
      () => {
        const messages = this._threadBinding.getState().messages;
        const message = messages[idx];
        if (!message) return void 0;
        return {
          message,
          parentId: messages[idx - 1]?.id ?? null
        };
      }
    );
  }
  getMesssageById(messageId) {
    return this._getMessageRuntime(
      {
        ...this.path,
        ref: this.path.ref + `${this.path.ref}.messages[messageId=${JSON.stringify(messageId)}]`,
        messageSelector: { type: "messageId", messageId }
      },
      () => this._threadBinding.getState().getMessageById(messageId)
    );
  }
  _getMessageRuntime(path, callback) {
    return new import_MessageRuntime.MessageRuntimeImpl(
      new import_ShallowMemoizeSubject.ShallowMemoizeSubject({
        path,
        getState: () => {
          const { message, parentId } = callback() ?? {};
          const { messages, speech: speechState } = this._threadBinding.getState();
          if (!message || parentId === void 0) return import_SKIP_UPDATE.SKIP_UPDATE;
          const thread = this._threadBinding.getState();
          const branches = thread.getBranches(message.id);
          const submittedFeedback = thread.getSubmittedFeedback(message.id);
          return {
            ...message,
            message,
            isLast: messages.at(-1)?.id === message.id,
            parentId,
            branches,
            branchNumber: branches.indexOf(message.id) + 1,
            branchCount: branches.length,
            speech: speechState?.messageId === message.id ? speechState : void 0,
            submittedFeedback
          };
        },
        subscribe: (callback2) => this._threadBinding.subscribe(callback2)
      }),
      this._threadBinding
    );
  }
  _eventListenerNestedSubscriptions = /* @__PURE__ */ new Map();
  unstable_on(event, callback) {
    let subject = this._eventListenerNestedSubscriptions.get(event);
    if (!subject) {
      subject = new import_NestedSubscriptionSubject.NestedSubscriptionSubject({
        path: this.path,
        getState: () => ({
          subscribe: (callback2) => this._threadBinding.getState().unstable_on(event, callback2)
        }),
        subscribe: (callback2) => this._threadBinding.outerSubscribe(callback2)
      });
      this._eventListenerNestedSubscriptions.set(event, subject);
    }
    return subject.subscribe(callback);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ThreadRuntimeImpl,
  getThreadState
});
//# sourceMappingURL=ThreadRuntime.js.map