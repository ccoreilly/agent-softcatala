{"version":3,"sources":["../../src/api/MessageRuntime.ts"],"sourcesContent":["import {\n  SpeechState,\n  SubmittedFeedback,\n} from \"../runtimes/core/ThreadRuntimeCore\";\nimport {\n  ThreadMessage,\n  ThreadAssistantContentPart,\n  ThreadUserContentPart,\n  Unsubscribe,\n} from \"../types\";\nimport {\n  ContentPartStatus,\n  ToolCallContentPartStatus,\n} from \"../types/AssistantTypes\";\nimport { getThreadMessageText } from \"../utils/getThreadMessageText\";\nimport {\n  AttachmentRuntime,\n  AttachmentState,\n  MessageAttachmentRuntimeImpl,\n} from \"./AttachmentRuntime\";\nimport {\n  EditComposerRuntime,\n  EditComposerRuntimeImpl,\n} from \"./ComposerRuntime\";\nimport {\n  ContentPartRuntime,\n  ContentPartRuntimeImpl,\n  ContentPartState,\n} from \"./ContentPartRuntime\";\nimport { MessageRuntimePath } from \"./RuntimePathTypes\";\nimport { ThreadRuntimeCoreBinding } from \"./ThreadRuntime\";\nimport { NestedSubscriptionSubject } from \"./subscribable/NestedSubscriptionSubject\";\nimport { SKIP_UPDATE } from \"./subscribable/SKIP_UPDATE\";\nimport { ShallowMemoizeSubject } from \"./subscribable/ShallowMemoizeSubject\";\nimport { SubscribableWithState } from \"./subscribable/Subscribable\";\n\nconst COMPLETE_STATUS: ContentPartStatus = {\n  type: \"complete\",\n};\n\nexport const toContentPartStatus = (\n  message: ThreadMessage,\n  partIndex: number,\n  part: ThreadUserContentPart | ThreadAssistantContentPart,\n): ToolCallContentPartStatus => {\n  if (message.role !== \"assistant\") return COMPLETE_STATUS;\n\n  if (part.type === \"tool-call\") {\n    if (!part.result) {\n      return message.status as ToolCallContentPartStatus;\n    } else {\n      return COMPLETE_STATUS;\n    }\n  }\n\n  const isLastPart = partIndex === Math.max(0, message.content.length - 1);\n  if (message.status.type === \"requires-action\") return COMPLETE_STATUS;\n  return isLastPart ? (message.status as ContentPartStatus) : COMPLETE_STATUS;\n};\n\nexport const EMPTY_CONTENT = Object.freeze({ type: \"text\", text: \"\" });\n\nconst getContentPartState = (\n  message: MessageState,\n  partIndex: number,\n): ContentPartState | SKIP_UPDATE => {\n  let part = message.content[partIndex];\n  if (!part) {\n    // for empty messages, show an empty text content part\n    if (message.content.length === 0 && partIndex === 0) {\n      part = EMPTY_CONTENT;\n    } else {\n      return SKIP_UPDATE;\n    }\n  } else if (\n    message.content.length === 1 &&\n    part.type === \"text\" &&\n    part.text.length === 0\n  ) {\n    // ensure reference equality for equivalent empty text parts\n    part = EMPTY_CONTENT;\n  }\n\n  // if the content part is the same, don't update\n  const status = toContentPartStatus(message, partIndex, part);\n  return Object.freeze({ ...part, part, status });\n};\n\nexport type MessageState = ThreadMessage & {\n  /**\n   * @deprecated You can directly access message fields in the state. Replace `.message.content` with `.content` etc. This will be removed in 0.6.0.\n   */\n  message: ThreadMessage;\n  parentId: string | null;\n  isLast: boolean;\n  /**\n   * @deprecated Use `branchNumber` and `branchCount` instead. This will be removed in 0.6.0.\n   */\n  branches: readonly string[];\n\n  branchNumber: number;\n  branchCount: number;\n\n  /**\n   * @deprecated This API is still under active development and might change without notice.\n   */\n  speech: SpeechState | undefined;\n  submittedFeedback: SubmittedFeedback | undefined;\n};\n\nexport type MessageStateBinding = SubscribableWithState<\n  MessageState,\n  MessageRuntimePath\n>;\n\nexport type MessageRuntime = {\n  readonly path: MessageRuntimePath;\n\n  readonly composer: EditComposerRuntime;\n\n  getState(): MessageState;\n  reload(): void;\n  /**\n   * @deprecated This API is still under active development and might change without notice.\n   */\n  speak(): void;\n  /**\n   * @deprecated This API is still under active development and might change without notice.\n   */\n  stopSpeaking(): void;\n  submitFeedback({ type }: { type: \"positive\" | \"negative\" }): void;\n  switchToBranch({\n    position,\n    branchId,\n  }: {\n    position?: \"previous\" | \"next\" | undefined;\n    branchId?: string | undefined;\n  }): void;\n  unstable_getCopyText(): string;\n\n  subscribe(callback: () => void): Unsubscribe;\n\n  getContentPartByIndex(idx: number): ContentPartRuntime;\n  getContentPartByToolCallId(toolCallId: string): ContentPartRuntime;\n\n  getAttachmentByIndex(idx: number): AttachmentRuntime & { source: \"message\" };\n};\n\nexport class MessageRuntimeImpl implements MessageRuntime {\n  public get path() {\n    return this._core.path;\n  }\n\n  constructor(\n    private _core: MessageStateBinding,\n    private _threadBinding: ThreadRuntimeCoreBinding,\n  ) {\n    this.composer = new EditComposerRuntimeImpl(\n      new NestedSubscriptionSubject({\n        path: {\n          ...this.path,\n          ref: this.path.ref + `${this.path.ref}.composer`,\n          composerSource: \"edit\",\n        },\n        getState: () =>\n          this._threadBinding\n            .getState()\n            .getEditComposer(this._core.getState().id),\n        subscribe: (callback) => this._threadBinding.subscribe(callback),\n      }),\n      () => this._threadBinding.getState().beginEdit(this._core.getState().id),\n    );\n  }\n\n  public composer;\n\n  public getState() {\n    return this._core.getState();\n  }\n\n  public reload() {\n    const state = this._core.getState();\n    if (state.role !== \"assistant\")\n      throw new Error(\"Can only reload assistant messages\");\n\n    this._threadBinding.getState().startRun(state.parentId);\n  }\n\n  public speak() {\n    const state = this._core.getState();\n    return this._threadBinding.getState().speak(state.id);\n  }\n\n  public stopSpeaking() {\n    const state = this._core.getState();\n    const thread = this._threadBinding.getState();\n    if (thread.speech?.messageId === state.id) {\n      this._threadBinding.getState().stopSpeaking();\n    } else {\n      throw new Error(\"Message is not being spoken\");\n    }\n  }\n\n  public submitFeedback({ type }: { type: \"positive\" | \"negative\" }) {\n    const state = this._core.getState();\n    this._threadBinding.getState().submitFeedback({\n      messageId: state.id,\n      type,\n    });\n  }\n\n  public switchToBranch({\n    position,\n    branchId,\n  }: {\n    position?: \"previous\" | \"next\" | undefined;\n    branchId?: string | undefined;\n  }) {\n    const state = this._core.getState();\n    if (branchId && position) {\n      throw new Error(\"May not specify both branchId and position\");\n    } else if (!branchId && !position) {\n      throw new Error(\"Must specify either branchId or position\");\n    }\n\n    const thread = this._threadBinding.getState();\n    const branches = thread.getBranches(state.id);\n    let targetBranch = branchId;\n    if (position === \"previous\") {\n      targetBranch = branches[state.branchNumber - 2];\n    } else if (position === \"next\") {\n      targetBranch = branches[state.branchNumber];\n    }\n    if (!targetBranch) throw new Error(\"Branch not found\");\n\n    this._threadBinding.getState().switchToBranch(targetBranch);\n  }\n\n  public unstable_getCopyText() {\n    return getThreadMessageText(this.getState());\n  }\n\n  public subscribe(callback: () => void) {\n    return this._core.subscribe(callback);\n  }\n\n  public getContentPartByIndex(idx: number) {\n    if (idx < 0) throw new Error(\"Content part index must be >= 0\");\n    return new ContentPartRuntimeImpl(\n      new ShallowMemoizeSubject({\n        path: {\n          ...this.path,\n          ref: this.path.ref + `${this.path.ref}.content[${idx}]`,\n          contentPartSelector: { type: \"index\", index: idx },\n        },\n        getState: () => {\n          return getContentPartState(this.getState(), idx);\n        },\n        subscribe: (callback) => this._core.subscribe(callback),\n      }),\n      this._core,\n      this._threadBinding,\n    );\n  }\n\n  public getContentPartByToolCallId(toolCallId: string) {\n    return new ContentPartRuntimeImpl(\n      new ShallowMemoizeSubject({\n        path: {\n          ...this.path,\n          ref:\n            this.path.ref +\n            `${this.path.ref}.content[toolCallId=${JSON.stringify(toolCallId)}]`,\n          contentPartSelector: { type: \"toolCallId\", toolCallId },\n        },\n        getState: () => {\n          const state = this._core.getState();\n          const idx = state.content.findIndex(\n            (part) =>\n              part.type === \"tool-call\" && part.toolCallId === toolCallId,\n          );\n          if (idx === -1) return SKIP_UPDATE;\n          return getContentPartState(state, idx);\n        },\n        subscribe: (callback) => this._core.subscribe(callback),\n      }),\n      this._core,\n      this._threadBinding,\n    );\n  }\n\n  public getAttachmentByIndex(idx: number) {\n    return new MessageAttachmentRuntimeImpl(\n      new ShallowMemoizeSubject({\n        path: {\n          ...this.path,\n          ref: this.path.ref + `${this.path.ref}.attachments[${idx}]`,\n          attachmentSource: \"message\",\n          attachmentSelector: { type: \"index\", index: idx },\n        },\n        getState: () => {\n          const attachments = this.getState().attachments;\n          const attachment = attachments?.[idx];\n          if (!attachment) return SKIP_UPDATE;\n\n          return {\n            ...attachment,\n            attachment: attachment,\n            source: \"message\",\n          } satisfies AttachmentState & { source: \"message\" };\n        },\n        subscribe: (callback) => this._core.subscribe(callback),\n      }),\n    );\n  }\n}\n"],"mappings":"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","names":[]}