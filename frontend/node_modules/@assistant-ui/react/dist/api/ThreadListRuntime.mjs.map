{"version":3,"sources":["../../src/api/ThreadListRuntime.ts"],"sourcesContent":["import { LazyMemoizeSubject } from \"./subscribable/LazyMemoizeSubject\";\nimport {\n  ThreadListMetadata,\n  ThreadListRuntimeCore,\n} from \"../runtimes/core/ThreadListRuntimeCore\";\nimport { Unsubscribe } from \"../types\";\nimport { ThreadListRuntimePath } from \"./RuntimePathTypes\";\nimport {\n  ThreadListItemRuntime,\n  ThreadListItemRuntimeImpl,\n} from \"./ThreadListItemRuntime\";\nimport { SKIP_UPDATE } from \"./subscribable/SKIP_UPDATE\";\n\nexport type ThreadListState = Readonly<{\n  threads: readonly ThreadListMetadata[];\n  archivedThreads: readonly ThreadListMetadata[];\n}>;\n\nexport type ThreadListRuntime = Readonly<{\n  path: ThreadListRuntimePath;\n  getState(): ThreadListState;\n\n  /**\n   * @deprecated Use `getThreadListItemById(idx).rename(newTitle)` instead. This will be removed in 0.6.0.\n   */\n  rename(threadId: string, newTitle: string): Promise<void>;\n  /**\n   * @deprecated Use `getThreadListItemById(idx).archive()` instead. This will be removed in 0.6.0.\n   */\n  archive(threadId: string): Promise<void>;\n  /**\n   * @deprecated Use `getThreadListItemById(idx).unarchive()` instead. This will be removed in 0.6.0.\n   */\n  unarchive(threadId: string): Promise<void>;\n  /**\n   * @deprecated Use `getThreadListItemById(idx).delete()` instead. This will be removed in 0.6.0.\n   */\n  delete(threadId: string): Promise<void>;\n\n  subscribe(callback: () => void): Unsubscribe;\n\n  getThreadListItemById(threadId: string): ThreadListItemRuntime;\n  getThreadListItemByIndex(idx: number): ThreadListItemRuntime;\n  getThreadListArchivedItemByIndex(idx: number): ThreadListItemRuntime;\n}>;\n\nconst getThreadListState = (\n  threadList: ThreadListRuntimeCore,\n): ThreadListState => {\n  return {\n    threads: threadList.threads,\n    archivedThreads: threadList.archivedThreads,\n  };\n};\n\nconst THREAD_MANAGER_PATH = {\n  ref: \"ThreadList\",\n};\n\nexport type ThreadListRuntimeCoreBinding = ThreadListRuntimeCore;\n\nexport class ThreadListRuntimeImpl implements ThreadListRuntime {\n  public get path() {\n    return THREAD_MANAGER_PATH;\n  }\n\n  private _getState;\n  constructor(private _core: ThreadListRuntimeCoreBinding) {\n    const stateBinding = new LazyMemoizeSubject({\n      path: THREAD_MANAGER_PATH,\n      getState: () => getThreadListState(_core),\n      subscribe: (callback) => _core.subscribe(callback),\n    });\n\n    this._getState = stateBinding.getState.bind(stateBinding);\n  }\n\n  public getState(): ThreadListState {\n    return this._getState();\n  }\n\n  public rename(threadId: string, newTitle: string): Promise<void> {\n    return this._core.rename(threadId, newTitle);\n  }\n\n  public archive(threadId: string): Promise<void> {\n    return this._core.archive(threadId);\n  }\n\n  public unarchive(threadId: string): Promise<void> {\n    return this._core.unarchive(threadId);\n  }\n\n  public delete(threadId: string): Promise<void> {\n    return this._core.delete(threadId);\n  }\n\n  public subscribe(callback: () => void): Unsubscribe {\n    return this._core.subscribe(callback);\n  }\n\n  public getThreadListItemByIndex(idx: number) {\n    return new ThreadListItemRuntimeImpl(\n      new LazyMemoizeSubject({\n        path: {\n          ref: this.path.ref + `${this.path.ref}.threadItems[${idx}]`,\n          threadSelector: { type: \"index\", index: idx },\n        },\n        getState: () => {\n          const threads = this._core.threads;\n          const thread = threads[idx];\n          if (!thread) return SKIP_UPDATE;\n          return thread;\n        },\n        subscribe: (callback) => this._core.subscribe(callback),\n      }),\n      this._core,\n    );\n  }\n\n  public getThreadListArchivedItemByIndex(idx: number) {\n    return new ThreadListItemRuntimeImpl(\n      new LazyMemoizeSubject({\n        path: {\n          ref: this.path.ref + `${this.path.ref}.archivedThreadItems[${idx}]`,\n          threadSelector: { type: \"archiveIndex\", index: idx },\n        },\n        getState: () => {\n          const threads = this._core.archivedThreads;\n          const thread = threads[idx];\n          if (!thread) return SKIP_UPDATE;\n          return thread;\n        },\n        subscribe: (callback) => this._core.subscribe(callback),\n      }),\n      this._core,\n    );\n  }\n\n  public getThreadListItemById(threadId: string) {\n    return new ThreadListItemRuntimeImpl(\n      new LazyMemoizeSubject({\n        path: {\n          ref:\n            this.path.ref +\n            `${this.path.ref}.threadItems[threadId=${threadId}]`,\n          threadSelector: { type: \"threadId\", threadId },\n        },\n        getState: () => {\n          const threadItem = this._core.getThreadMetadataById(threadId);\n          if (!threadItem) return SKIP_UPDATE;\n          return threadItem;\n        },\n        subscribe: (callback) => this._core.subscribe(callback),\n      }),\n      this._core,\n    );\n  }\n}\n"],"mappings":"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","names":[]}