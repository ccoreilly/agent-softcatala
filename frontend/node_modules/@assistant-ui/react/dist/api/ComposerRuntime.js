"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/api/ComposerRuntime.ts
var ComposerRuntime_exports = {};
__export(ComposerRuntime_exports, {
  ComposerRuntimeImpl: () => ComposerRuntimeImpl,
  EditComposerRuntimeImpl: () => EditComposerRuntimeImpl,
  ThreadComposerRuntimeImpl: () => ThreadComposerRuntimeImpl
});
module.exports = __toCommonJS(ComposerRuntime_exports);
var import_LazyMemoizeSubject = require("./subscribable/LazyMemoizeSubject.cjs");
var import_AttachmentRuntime = require("./AttachmentRuntime.cjs");
var import_ShallowMemoizeSubject = require("./subscribable/ShallowMemoizeSubject.cjs");
var import_SKIP_UPDATE = require("./subscribable/SKIP_UPDATE.cjs");
var METHOD_NOT_SUPPORTED = () => {
  throw new Error("Composer is not available");
};
var EMPTY_ARRAY = Object.freeze([]);
var getThreadComposerState = (runtime) => {
  return Object.freeze({
    type: "thread",
    isEditing: runtime?.isEditing ?? false,
    canCancel: runtime?.canCancel ?? false,
    isEmpty: runtime?.isEmpty ?? true,
    text: runtime?.text ?? "",
    attachments: runtime?.attachments ?? EMPTY_ARRAY,
    role: runtime?.role ?? "user",
    value: runtime?.text ?? "",
    setValue: runtime?.setText.bind(runtime) ?? METHOD_NOT_SUPPORTED,
    setText: runtime?.setText.bind(runtime) ?? METHOD_NOT_SUPPORTED,
    // edit: beginEdit,
    send: runtime?.send.bind(runtime) ?? METHOD_NOT_SUPPORTED,
    cancel: runtime?.cancel.bind(runtime) ?? METHOD_NOT_SUPPORTED,
    reset: runtime?.reset.bind(runtime) ?? METHOD_NOT_SUPPORTED,
    addAttachment: runtime?.addAttachment.bind(runtime) ?? METHOD_NOT_SUPPORTED,
    removeAttachment: runtime?.removeAttachment.bind(runtime) ?? METHOD_NOT_SUPPORTED
  });
};
var getEditComposerState = (runtime, beginEdit) => {
  return Object.freeze({
    type: "edit",
    isEditing: runtime?.isEditing ?? false,
    canCancel: runtime?.canCancel ?? false,
    isEmpty: runtime?.isEmpty ?? true,
    text: runtime?.text ?? "",
    attachments: runtime?.attachments ?? EMPTY_ARRAY,
    role: runtime?.role ?? "user",
    value: runtime?.text ?? "",
    setValue: runtime?.setText.bind(runtime) ?? METHOD_NOT_SUPPORTED,
    setText: runtime?.setText.bind(runtime) ?? METHOD_NOT_SUPPORTED,
    edit: beginEdit,
    send: runtime?.send.bind(runtime) ?? METHOD_NOT_SUPPORTED,
    cancel: runtime?.cancel.bind(runtime) ?? METHOD_NOT_SUPPORTED
  });
};
var ComposerRuntimeImpl = class {
  constructor(_core) {
    this._core = _core;
  }
  get path() {
    return this._core.path;
  }
  /**
   * @deprecated Use `getState().isEditing` instead. This will be removed in 0.6.0.
   */
  get isEditing() {
    return this.getState().isEditing;
  }
  /**
   * @deprecated Use `getState().isEmpty` instead. This will be removed in 0.6.0.
   */
  get isEmpty() {
    return this.getState().isEmpty;
  }
  /**
   * @deprecated Use `getState().canCancel` instead. This will be removed in 0.6.0.
   */
  get canCancel() {
    return this.getState().canCancel;
  }
  /**
   * @deprecated Use `getState().text` instead. This will be removed in 0.6.0.
   */
  get text() {
    return this.getState().text;
  }
  /**
   * @deprecated Use `getState().role` instead. This will be removed in 0.6.0.
   */
  get role() {
    return this.getState().role;
  }
  /**
   * @deprecated Use `getState().attachments` instead. This will be removed in 0.6.0.
   */
  get attachments() {
    return this.getState().attachments;
  }
  /**
   * @deprecated Use `getState().text` instead. This will be removed in 0.6.0.
   */
  get value() {
    return this.text;
  }
  setText(text) {
    const core = this._core.getState();
    if (!core) throw new Error("Composer is not available");
    core.setText(text);
  }
  setValue(text) {
    this.setText(text);
  }
  addAttachment(file) {
    const core = this._core.getState();
    if (!core) throw new Error("Composer is not available");
    return core.addAttachment(file);
  }
  /**
   * @deprecated Use `getAttachmentById(id).removeAttachment()` instead. This will be removed in 0.6.0.
   */
  removeAttachment(attachmentId) {
    const core = this._core.getState();
    if (!core) throw new Error("Composer is not available");
    return core.removeAttachment(attachmentId);
  }
  /**
   * @deprecated This method will be removed in 0.6.0. Submit feedback if you need this functionality.
   */
  reset() {
    const core = this._core.getState();
    if (!core) throw new Error("Composer is not available");
    core.reset();
  }
  send() {
    const core = this._core.getState();
    if (!core) throw new Error("Composer is not available");
    core.send();
  }
  cancel() {
    const core = this._core.getState();
    if (!core) throw new Error("Composer is not available");
    core.cancel();
  }
  setRole(role) {
    const core = this._core.getState();
    if (!core) throw new Error("Composer is not available");
    core.setRole(role);
  }
  subscribe(callback) {
    return this._core.subscribe(callback);
  }
  getAttachmentAccept() {
    const core = this._core.getState();
    if (!core) throw new Error("Composer is not available");
    return core.getAttachmentAccept();
  }
};
var ThreadComposerRuntimeImpl = class extends ComposerRuntimeImpl {
  get path() {
    return this._core.path;
  }
  get type() {
    return "thread";
  }
  _getState;
  constructor(core) {
    const stateBinding = new import_LazyMemoizeSubject.LazyMemoizeSubject({
      path: core.path,
      getState: () => getThreadComposerState(core.getState()),
      subscribe: (callback) => core.subscribe(callback)
    });
    super({
      path: core.path,
      getState: () => core.getState(),
      subscribe: (callback) => stateBinding.subscribe(callback)
    });
    this._getState = stateBinding.getState.bind(stateBinding);
  }
  get attachments() {
    return this.getState()?.attachments ?? EMPTY_ARRAY;
  }
  getState() {
    return this._getState();
  }
  getAttachmentByIndex(idx) {
    return new import_AttachmentRuntime.ThreadComposerAttachmentRuntimeImpl(
      new import_ShallowMemoizeSubject.ShallowMemoizeSubject({
        path: {
          ...this.path,
          attachmentSource: "thread-composer",
          attachmentSelector: { type: "index", index: idx },
          ref: this.path.ref + `${this.path.ref}.attachments[${idx}]`
        },
        getState: () => {
          const attachments = this.getState().attachments;
          const attachment = attachments[idx];
          if (!attachment) return import_SKIP_UPDATE.SKIP_UPDATE;
          return {
            ...attachment,
            attachment,
            source: "thread-composer"
          };
        },
        subscribe: (callback) => this._core.subscribe(callback)
      }),
      this._core
    );
  }
};
var EditComposerRuntimeImpl = class extends ComposerRuntimeImpl {
  constructor(core, _beginEdit) {
    const stateBinding = new import_LazyMemoizeSubject.LazyMemoizeSubject({
      path: core.path,
      getState: () => getEditComposerState(core.getState(), this._beginEdit),
      subscribe: (callback) => core.subscribe(callback)
    });
    super({
      path: core.path,
      getState: () => core.getState(),
      subscribe: (callback) => stateBinding.subscribe(callback)
    });
    this._beginEdit = _beginEdit;
    this._getState = stateBinding.getState.bind(stateBinding);
  }
  get path() {
    return this._core.path;
  }
  get type() {
    return "edit";
  }
  _getState;
  getState() {
    return this._getState();
  }
  beginEdit() {
    this._beginEdit();
  }
  /**
   * @deprecated Use `beginEdit()` instead. This will be removed in 0.6.0.
   */
  edit() {
    this.beginEdit();
  }
  getAttachmentByIndex(idx) {
    return new import_AttachmentRuntime.EditComposerAttachmentRuntimeImpl(
      new import_ShallowMemoizeSubject.ShallowMemoizeSubject({
        path: {
          ...this.path,
          attachmentSource: "edit-composer",
          attachmentSelector: { type: "index", index: idx },
          ref: this.path.ref + `${this.path.ref}.attachments[${idx}]`
        },
        getState: () => {
          const attachments = this.getState().attachments;
          const attachment = attachments[idx];
          if (!attachment) return import_SKIP_UPDATE.SKIP_UPDATE;
          return {
            ...attachment,
            attachment,
            source: "edit-composer"
          };
        },
        subscribe: (callback) => this._core.subscribe(callback)
      }),
      this._core
    );
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ComposerRuntimeImpl,
  EditComposerRuntimeImpl,
  ThreadComposerRuntimeImpl
});
//# sourceMappingURL=ComposerRuntime.js.map