import { AddToolResultOptions, ThreadSuggestion, RuntimeCapabilities, SubmitFeedbackOptions, ThreadRuntimeCore, SpeechState, SubmittedFeedback, ThreadRuntimeEventType } from "../runtimes/core/ThreadRuntimeCore";
import { ExportedMessageRepository } from "../runtimes/utils/MessageRepository";
import { AppendMessage, ModelConfig, ThreadMessage, Unsubscribe } from "../types";
import { MessageRuntime, MessageRuntimeImpl } from "./MessageRuntime";
import { SubscribableWithState } from "./subscribable/Subscribable";
import { ThreadComposerRuntime, ThreadComposerRuntimeImpl } from "./ComposerRuntime";
import { ComposerRuntimeCore } from "../runtimes/core/ComposerRuntimeCore";
import { ThreadRuntimePath } from "./RuntimePathTypes";
export type CreateAppendMessage = string | {
    parentId?: string | null | undefined;
    role?: AppendMessage["role"] | undefined;
    content: AppendMessage["content"];
    attachments?: AppendMessage["attachments"] | undefined;
    startRun?: boolean | undefined;
};
export type ThreadRuntimeCoreBinding = SubscribableWithState<ThreadRuntimeCore, ThreadRuntimePath> & {
    outerSubscribe(callback: () => void): Unsubscribe;
};
export type ThreadState = Readonly<{
    /**
     * The thread ID.
     */
    threadId: string;
    /**
     * Whether the thread is disabled. Disabled threads cannot receive new messages.
     */
    isDisabled: boolean;
    /**
     * Whether the thread is running. A thread is considered running when there is an active stream connection to the backend.
     */
    isRunning: boolean;
    /**
     * The capabilities of the thread, such as whether the thread supports editing, branch switching, etc.
     */
    capabilities: RuntimeCapabilities;
    /**
     * The messages in the currently selected branch of the thread.
     */
    messages: readonly ThreadMessage[];
    /**
     * Follow up message suggestions to show the user.
     */
    suggestions: readonly ThreadSuggestion[];
    /**
     * Custom extra information provided by the runtime.
     */
    extras: unknown;
    /**
     * @deprecated This API is still under active development and might change without notice.
     */
    speech: SpeechState | undefined;
}>;
export declare const getThreadState: (runtime: ThreadRuntimeCore) => ThreadState;
export type ThreadRuntime = Readonly<{
    readonly path: ThreadRuntimePath;
    readonly composer: ThreadComposerRuntime;
    getState(): ThreadState;
    /**
     * @deprecated This method will be removed in 0.6.0. Submit feedback if you need this functionality.
     */
    unstable_getCore(): ThreadRuntimeCore;
    append(message: CreateAppendMessage): void;
    startRun(parentId: string | null): void;
    subscribe(callback: () => void): Unsubscribe;
    cancelRun(): void;
    getModelConfig(): ModelConfig;
    export(): ExportedMessageRepository;
    import(repository: ExportedMessageRepository): void;
    getMesssageByIndex(idx: number): MessageRuntime;
    getMesssageById(messageId: string): MessageRuntime;
    /**
     * @deprecated This API is still under active development and might change without notice.
     */
    stopSpeaking: () => void;
    unstable_on(event: ThreadRuntimeEventType, callback: () => void): Unsubscribe;
    /**
     * @deprecated Use `getState().capabilities` instead. This will be removed in 0.6.0.
     */
    capabilities: Readonly<RuntimeCapabilities>;
    /**
     * @deprecated Use `getState().threadId` instead. This will be removed in 0.6.0.
     */
    threadId: string;
    /**
     * @deprecated Use `getState().isDisabled` instead. This will be removed in 0.6.0.
     */
    isDisabled: boolean;
    /**
     * @deprecated Use `getState().isRunning` instead. This will be removed in 0.6.0.
     */
    isRunning: boolean;
    /**
     * @deprecated Use `getState().messages` instead. This will be removed in 0.6.0.
     */
    messages: readonly ThreadMessage[];
    /**
     * @deprecated Use `getState().followupSuggestions` instead. This will be removed in 0.6.0.
     */
    suggestions: readonly ThreadSuggestion[];
    /**
     * @deprecated Use `getState().speechState` instead. This will be removed in 0.6.0.
     */
    speech: SpeechState | undefined;
    /**
     * @deprecated Use `getState().extras` instead. This will be removed in 0.6.0.
     */
    extras: unknown;
    /**
     * @deprecated Use `getMesssageById(id).getState().branchNumber` / `getMesssageById(id).getState().branchCount` instead. This will be removed in 0.6.0.
     */
    getBranches: (messageId: string) => readonly string[];
    /**
     * @deprecated Use `getMesssageById(id).switchToBranch({ options })` instead. This will be removed in 0.6.0.
     */
    switchToBranch: (branchId: string) => void;
    /**
     * @deprecated Use `getMesssageById(id).getContentPartByToolCallId(toolCallId).addToolResult({ result })` instead. This will be removed in 0.6.0.
     */
    addToolResult: (options: AddToolResultOptions) => void;
    /**
     * @deprecated Use `getMesssageById(id).speak()` instead. This will be removed in 0.6.0.
     */
    speak: (messageId: string) => void;
    /**
     * @deprecated Use `getMesssageById(id).getState().submittedFeedback` instead. This will be removed in 0.6.0.
     */
    getSubmittedFeedback: (messageId: string) => SubmittedFeedback | undefined;
    /**
     * @deprecated Use `getMesssageById(id).submitFeedback({ type })` instead. This will be removed in 0.6.0.
     */
    submitFeedback: (feedback: SubmitFeedbackOptions) => void;
    /**
     * @deprecated Use `getMesssageById(id).composer` instead. This will be removed in 0.6.0.
     */
    getEditComposer: (messageId: string) => ComposerRuntimeCore | undefined;
    /**
     * @deprecated Use `getMesssageById(id).composer.beginEdit()` instead. This will be removed in 0.6.0.
     */
    beginEdit: (messageId: string) => void;
}>;
export declare class ThreadRuntimeImpl implements Omit<ThreadRuntimeCore, "getMessageById">, ThreadRuntime {
    get path(): ThreadRuntimePath;
    /**
     * @deprecated Use `getState().threadId` instead. This will be removed in 0.6.0.
     */
    get threadId(): string;
    /**
     * @deprecated Use `getState().isDisabled` instead. This will be removed in 0.6.0.
     */
    get isDisabled(): boolean;
    /**
     * @deprecated Use `getState().isRunning` instead. This will be removed in 0.6.0.
     */
    get isRunning(): boolean;
    /**
     * @deprecated Use `getState().capabilities` instead. This will be removed in 0.6.0.
     */
    get capabilities(): Readonly<{
        switchToBranch: boolean;
        edit: boolean;
        reload: boolean;
        cancel: boolean;
        unstable_copy: boolean;
        speech: boolean;
        attachments: boolean;
        feedback: boolean;
    }>;
    /**
     * @deprecated Use `getState().extras` instead. This will be removed in 0.6.0.
     */
    get extras(): unknown;
    /**
     * @deprecated Use `getState().followupSuggestions` instead. This will be removed in 0.6.0.
     */
    get suggestions(): readonly ThreadSuggestion[];
    /**
     * @deprecated Use `getState().messages` instead. This will be removed in 0.6.0.
     */
    get messages(): readonly ThreadMessage[];
    /**
     * @deprecated Use `getState().speechState` instead. This will be removed in 0.6.0.
     */
    get speech(): Readonly<{
        messageId: string;
        status: import("..").SpeechSynthesisAdapter.Status;
    }> | undefined;
    unstable_getCore(): Readonly<{
        getMessageById: (messageId: string) => {
            parentId: string | null;
            message: ThreadMessage;
        } | undefined;
        getBranches: (messageId: string) => readonly string[];
        switchToBranch: (branchId: string) => void;
        append: (message: AppendMessage) => void;
        startRun: (parentId: string | null) => void;
        cancelRun: () => void;
        addToolResult: (options: AddToolResultOptions) => void;
        speak: (messageId: string) => void;
        stopSpeaking: () => void;
        getSubmittedFeedback: (messageId: string) => SubmittedFeedback | undefined;
        submitFeedback: (feedback: SubmitFeedbackOptions) => void;
        getModelConfig: () => ModelConfig;
        composer: import("../runtimes/core/ComposerRuntimeCore").ThreadComposerRuntimeCore;
        getEditComposer: (messageId: string) => ComposerRuntimeCore | undefined;
        beginEdit: (messageId: string) => void;
        speech: SpeechState | undefined;
        capabilities: Readonly<RuntimeCapabilities>;
        threadId: string;
        isDisabled: boolean;
        messages: readonly ThreadMessage[];
        suggestions: readonly ThreadSuggestion[];
        extras: unknown;
        subscribe: (callback: () => void) => Unsubscribe;
        import(repository: ExportedMessageRepository): void;
        export(): ExportedMessageRepository;
        unstable_on(event: ThreadRuntimeEventType, callback: () => void): Unsubscribe;
    }>;
    private _threadBinding;
    constructor(threadBinding: ThreadRuntimeCoreBinding);
    readonly composer: ThreadComposerRuntimeImpl;
    getState(): Readonly<{
        /**
         * The thread ID.
         */
        threadId: string;
        /**
         * Whether the thread is disabled. Disabled threads cannot receive new messages.
         */
        isDisabled: boolean;
        /**
         * Whether the thread is running. A thread is considered running when there is an active stream connection to the backend.
         */
        isRunning: boolean;
        /**
         * The capabilities of the thread, such as whether the thread supports editing, branch switching, etc.
         */
        capabilities: RuntimeCapabilities;
        /**
         * The messages in the currently selected branch of the thread.
         */
        messages: readonly ThreadMessage[];
        /**
         * Follow up message suggestions to show the user.
         */
        suggestions: readonly ThreadSuggestion[];
        /**
         * Custom extra information provided by the runtime.
         */
        extras: unknown;
        /**
         * @deprecated This API is still under active development and might change without notice.
         */
        speech: SpeechState | undefined;
    }>;
    append(message: CreateAppendMessage): void;
    subscribe(callback: () => void): Unsubscribe;
    /**
     * @derprecated Use `getMesssageById(id).getState().branchNumber` / `getMesssageById(id).getState().branchCount` instead. This will be removed in 0.6.0.
     */
    getBranches(messageId: string): readonly string[];
    getModelConfig(): ModelConfig;
    startRun(parentId: string | null): void;
    cancelRun(): void;
    /**
     * @deprecated Use `getMesssageById(id).getContentPartByToolCallId(toolCallId).addToolResult({ result })` instead. This will be removed in 0.6.0.
     */
    addToolResult(options: AddToolResultOptions): void;
    /**
     * @deprecated Use `getMesssageById(id).switchToBranch({ options })` instead. This will be removed in 0.6.0.
     */
    switchToBranch(branchId: string): void;
    /**
     * @deprecated Use `getMesssageById(id).speak()` instead. This will be removed in 0.6.0.
     */
    speak(messageId: string): void;
    stopSpeaking(): void;
    getSubmittedFeedback(messageId: string): Readonly<{
        type: "negative" | "positive";
    }> | undefined;
    /**
     * @deprecated Use `getMesssageById(id).submitFeedback({ type })` instead. This will be removed in 0.6.0.
     */
    submitFeedback(options: SubmitFeedbackOptions): void;
    /**
     * @deprecated Use `getMesssageById(id).getMessageByIndex(idx).composer` instead. This will be removed in 0.6.0.
     */
    getEditComposer(messageId: string): Readonly<{
        attachments: readonly import("..").Attachment[];
        getAttachmentAccept(): string;
        addAttachment: (file: File) => Promise<void>;
        removeAttachment: (attachmentId: string) => Promise<void>;
        isEditing: boolean;
        canCancel: boolean;
        isEmpty: boolean;
        text: string;
        setText: (value: string) => void;
        role: import("../types/AssistantTypes").MessageRole;
        setRole: (role: import("../types/AssistantTypes").MessageRole) => void;
        reset: () => void;
        send: () => void;
        cancel: () => void;
        subscribe: (callback: () => void) => Unsubscribe;
    }> | undefined;
    /**
     * @deprecated Use `getMesssageById(id).getMessageByIndex(idx).composer.beginEdit()` instead. This will be removed in 0.6.0.
     */
    beginEdit(messageId: string): void;
    export(): ExportedMessageRepository;
    import(data: ExportedMessageRepository): void;
    getMesssageByIndex(idx: number): MessageRuntimeImpl;
    getMesssageById(messageId: string): MessageRuntimeImpl;
    private _getMessageRuntime;
    private _eventListenerNestedSubscriptions;
    unstable_on(event: ThreadRuntimeEventType, callback: () => void): Unsubscribe;
}
//# sourceMappingURL=ThreadRuntime.d.ts.map