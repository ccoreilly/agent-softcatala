"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/runtimes/external-store/ExternalStoreThreadListRuntimeCore.tsx
var ExternalStoreThreadListRuntimeCore_exports = {};
__export(ExternalStoreThreadListRuntimeCore_exports, {
  ExternalStoreThreadListRuntimeCore: () => ExternalStoreThreadListRuntimeCore
});
module.exports = __toCommonJS(ExternalStoreThreadListRuntimeCore_exports);
var EMPTY_ARRAY = Object.freeze([]);
var DEFAULT_THREAD_ID = "DEFAULT_THREAD_ID";
var ExternalStoreThreadListRuntimeCore = class {
  constructor(adapter = {}, threadFactory) {
    this.adapter = adapter;
    this.threadFactory = threadFactory;
    this._mainThread = this.threadFactory(DEFAULT_THREAD_ID);
  }
  get threads() {
    return this.adapter.threads ?? EMPTY_ARRAY;
  }
  get archivedThreads() {
    return this.adapter.archivedThreads ?? EMPTY_ARRAY;
  }
  _mainThread;
  get mainThread() {
    return this._mainThread;
  }
  getThreadMetadataById(threadId) {
    for (const thread of this.threads) {
      if (thread.threadId === threadId) return thread;
    }
    for (const thread of this.archivedThreads) {
      if (thread.threadId === threadId) return thread;
    }
    return void 0;
  }
  setAdapter(adapter) {
    const previousAdapter = this.adapter;
    this.adapter = adapter;
    const newThreadId = adapter.threadId ?? DEFAULT_THREAD_ID;
    const newThreads = adapter.threads ?? EMPTY_ARRAY;
    const newArchivedThreads = adapter.archivedThreads ?? EMPTY_ARRAY;
    const previousThreadId = previousAdapter.threadId ?? DEFAULT_THREAD_ID;
    const previousThreads = previousAdapter.threads ?? EMPTY_ARRAY;
    const previousArchivedThreads = previousAdapter.archivedThreads ?? EMPTY_ARRAY;
    if (previousThreadId === newThreadId && previousThreads === newThreads && previousArchivedThreads === newArchivedThreads) {
      return;
    }
    if (previousAdapter.threadId !== newThreadId) {
      this._mainThread._notifyEventSubscribers("switched-away");
      this._mainThread = this.threadFactory(newThreadId);
      this._mainThread._notifyEventSubscribers("switched-to");
    }
    this._notifySubscribers();
  }
  switchToThread(threadId) {
    if (this._mainThread?.threadId === threadId) return;
    const onSwitchToThread = this.adapter.onSwitchToThread;
    if (!onSwitchToThread)
      throw new Error(
        "External store adapter does not support switching to thread"
      );
    onSwitchToThread(threadId);
  }
  switchToNewThread() {
    const onSwitchToNewThread = this.adapter.onSwitchToNewThread;
    if (!onSwitchToNewThread)
      throw new Error(
        "External store adapter does not support switching to new thread"
      );
    onSwitchToNewThread();
  }
  async rename(threadId, newTitle) {
    const onRename = this.adapter.onRename;
    if (!onRename)
      throw new Error("External store adapter does not support renaming");
    onRename(threadId, newTitle);
  }
  async archive(threadId) {
    const onArchive = this.adapter.onArchive;
    if (!onArchive)
      throw new Error("External store adapter does not support archiving");
    onArchive(threadId);
  }
  async unarchive(threadId) {
    const onUnarchive = this.adapter.onUnarchive;
    if (!onUnarchive)
      throw new Error("External store adapter does not support unarchiving");
    onUnarchive(threadId);
  }
  async delete(threadId) {
    const onDelete = this.adapter.onDelete;
    if (!onDelete)
      throw new Error("External store adapter does not support deleting");
    onDelete(threadId);
  }
  _subscriptions = /* @__PURE__ */ new Set();
  subscribe(callback) {
    this._subscriptions.add(callback);
    return () => this._subscriptions.delete(callback);
  }
  _notifySubscribers() {
    for (const callback of this._subscriptions) callback();
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ExternalStoreThreadListRuntimeCore
});
//# sourceMappingURL=ExternalStoreThreadListRuntimeCore.js.map