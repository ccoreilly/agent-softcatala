import { AddToolResultOptions, ThreadSuggestion } from "../core/ThreadRuntimeCore";
import { AppendMessage, ModelConfigProvider, ThreadMessage } from "../../types";
import { ExternalStoreAdapter } from "./ExternalStoreAdapter";
import { ThreadRuntimeCore } from "../core/ThreadRuntimeCore";
import { BaseThreadRuntimeCore } from "../core/BaseThreadRuntimeCore";
export declare const hasUpcomingMessage: (isRunning: boolean, messages: ThreadMessage[]) => boolean;
export declare class ExternalStoreThreadRuntimeCore extends BaseThreadRuntimeCore implements ThreadRuntimeCore {
    private assistantOptimisticId;
    private _capabilities;
    get capabilities(): Readonly<{
        switchToBranch: boolean;
        edit: boolean;
        reload: boolean;
        cancel: boolean;
        unstable_copy: boolean;
        speech: boolean;
        attachments: boolean;
        feedback: boolean;
    }>;
    threadId: string;
    private _messages;
    isDisabled: boolean;
    get messages(): ThreadMessage[];
    get adapters(): {
        attachments?: import("..").AttachmentAdapter | undefined;
        speech?: import("..").SpeechSynthesisAdapter | undefined;
        feedback?: import("..").FeedbackAdapter | undefined;
        threadList?: import("./ExternalStoreAdapter").ExternalStoreThreadListAdapter | undefined;
    } | undefined;
    suggestions: readonly ThreadSuggestion[];
    extras: unknown;
    private _converter;
    private _store;
    beginEdit(messageId: string): void;
    constructor(configProvider: ModelConfigProvider, threadId: string, store: ExternalStoreAdapter<any>);
    setStore(store: ExternalStoreAdapter<any>): void;
    switchToBranch(branchId: string): void;
    append(message: AppendMessage): Promise<void>;
    startRun(parentId: string | null): Promise<void>;
    cancelRun(): void;
    addToolResult(options: AddToolResultOptions): void;
    private updateMessages;
}
//# sourceMappingURL=ExternalStoreThreadRuntimeCore.d.ts.map