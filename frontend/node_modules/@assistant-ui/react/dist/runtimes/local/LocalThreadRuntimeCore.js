"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/runtimes/local/LocalThreadRuntimeCore.tsx
var LocalThreadRuntimeCore_exports = {};
__export(LocalThreadRuntimeCore_exports, {
  LocalThreadRuntimeCore: () => LocalThreadRuntimeCore
});
module.exports = __toCommonJS(LocalThreadRuntimeCore_exports);
var import_internal = require("../../internal.cjs");
var import_edge = require("../edge/index.cjs");
var import_shouldContinue = require("./shouldContinue.cjs");
var import_BaseThreadRuntimeCore = require("../core/BaseThreadRuntimeCore.cjs");
var LocalThreadRuntimeCore = class extends import_BaseThreadRuntimeCore.BaseThreadRuntimeCore {
  constructor(configProvider, threadId, options) {
    super(configProvider);
    this.threadId = threadId;
    this.setOptions(options);
  }
  capabilities = {
    switchToBranch: true,
    edit: true,
    reload: true,
    cancel: true,
    unstable_copy: true,
    speech: false,
    attachments: false,
    feedback: false
  };
  abortController = null;
  isDisabled = false;
  suggestions = [];
  get adapters() {
    return this._options.adapters;
  }
  _options;
  get extras() {
    return void 0;
  }
  setOptions(options) {
    if (this._options === options) return;
    this._options = options;
    let hasUpdates = false;
    const canSpeak = options.adapters?.speech !== void 0;
    if (this.capabilities.speech !== canSpeak) {
      this.capabilities.speech = canSpeak;
      hasUpdates = true;
    }
    const canAttach = options.adapters?.attachments !== void 0;
    if (this.capabilities.attachments !== canAttach) {
      this.capabilities.attachments = canAttach;
      hasUpdates = true;
    }
    const canFeedback = options.adapters?.feedback !== void 0;
    if (this.capabilities.feedback !== canFeedback) {
      this.capabilities.feedback = canFeedback;
      hasUpdates = true;
    }
    if (hasUpdates) this._notifySubscribers();
  }
  async append(message) {
    const newMessage = (0, import_edge.fromCoreMessage)(message, {
      attachments: message.attachments
    });
    this.repository.addOrUpdateMessage(message.parentId, newMessage);
    const startRun = message.startRun ?? message.role === "user";
    if (startRun) {
      await this.startRun(newMessage.id);
    } else {
      this.repository.resetHead(newMessage.id);
      this._notifySubscribers();
    }
  }
  async startRun(parentId) {
    this.repository.resetHead(parentId);
    const id = (0, import_internal.generateId)();
    let message = {
      id,
      role: "assistant",
      status: { type: "running" },
      content: [],
      createdAt: /* @__PURE__ */ new Date()
    };
    this._notifyEventSubscribers("run-start");
    do {
      message = await this.performRoundtrip(parentId, message);
    } while ((0, import_shouldContinue.shouldContinue)(message));
  }
  async performRoundtrip(parentId, message) {
    const messages = this.repository.getMessages();
    this.abortController?.abort();
    this.abortController = new AbortController();
    const initialContent = message.content;
    const initialSteps = message.metadata?.steps;
    const initalCustom = message.metadata?.custom;
    const updateMessage = (m) => {
      const newSteps = m.metadata?.steps || m.metadata?.roundtrips;
      const steps2 = newSteps ? [...initialSteps ?? [], ...newSteps] : void 0;
      message = {
        ...message,
        ...m.content ? { content: [...initialContent, ...m.content ?? []] } : void 0,
        status: m.status ?? message.status,
        // TODO deprecated, remove in v0.6
        ...steps2 ? { roundtrips: steps2 } : void 0,
        ...m.metadata ? {
          metadata: {
            ...message.metadata,
            ...steps2 ? { roundtrips: steps2, steps: steps2 } : void 0,
            ...m.metadata?.custom ? {
              custom: { ...initalCustom ?? {}, ...m.metadata.custom }
            } : void 0
          }
        } : void 0
      };
      this.repository.addOrUpdateMessage(parentId, message);
      this._notifySubscribers();
    };
    const maxSteps = this._options.maxSteps ? this._options.maxSteps : (this._options.maxToolRoundtrips ?? 1) + 1;
    const steps = message.metadata?.steps?.length ?? 0;
    if (steps >= maxSteps) {
      updateMessage({
        status: {
          type: "incomplete",
          reason: "tool-calls"
        }
      });
      return message;
    } else {
      updateMessage({
        status: {
          type: "running"
        }
      });
    }
    try {
      const promiseOrGenerator = this.adapters.chatModel.run({
        messages,
        abortSignal: this.abortController.signal,
        config: this.getModelConfig(),
        onUpdate: updateMessage,
        unstable_assistantMessageId: message.id
      });
      if (Symbol.asyncIterator in promiseOrGenerator) {
        for await (const r of promiseOrGenerator) {
          updateMessage(r);
        }
      } else {
        updateMessage(await promiseOrGenerator);
      }
      this.abortController = null;
      if (message.status.type === "running") {
        updateMessage({
          status: { type: "complete", reason: "unknown" }
        });
      }
    } catch (e) {
      this.abortController = null;
      if (e instanceof Error && e.name === "AbortError") {
        updateMessage({
          status: { type: "incomplete", reason: "cancelled" }
        });
      } else {
        updateMessage({
          status: { type: "incomplete", reason: "error", error: e }
        });
        throw e;
      }
    }
    return message;
  }
  cancelRun() {
    this.abortController?.abort();
    this.abortController = null;
  }
  addToolResult({
    messageId,
    toolCallId,
    result
  }) {
    const messageData = this.repository.getMessage(messageId);
    const { parentId } = messageData;
    let { message } = messageData;
    if (message.role !== "assistant")
      throw new Error("Tried to add tool result to non-assistant message");
    let added = false;
    let found = false;
    const newContent = message.content.map((c) => {
      if (c.type !== "tool-call") return c;
      if (c.toolCallId !== toolCallId) return c;
      found = true;
      if (!c.result) added = true;
      return {
        ...c,
        result
      };
    });
    if (!found)
      throw new Error("Tried to add tool result to non-existing tool call");
    message = {
      ...message,
      content: newContent
    };
    this.repository.addOrUpdateMessage(parentId, message);
    if (added && (0, import_shouldContinue.shouldContinue)(message)) {
      this.performRoundtrip(parentId, message);
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  LocalThreadRuntimeCore
});
//# sourceMappingURL=LocalThreadRuntimeCore.js.map