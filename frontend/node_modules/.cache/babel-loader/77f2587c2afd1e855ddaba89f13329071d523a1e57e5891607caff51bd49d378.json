{"ast":null,"code":"// Convert assistant-ui message format to our backend format\nconst convertToBackendMessage = message => ({\n  role: message.role,\n  content: typeof message.content === 'string' ? message.content : Array.isArray(message.content) ? message.content.map(part => part.type === 'text' ? part.text : '').join('') : '',\n  timestamp: new Date().toISOString()\n});\n\n// Simple fetch function for streaming\nexport const streamChatResponse = async (messages, onUpdate, signal) => {\n  const baseUrl = process.env.NODE_ENV === 'production' ? window.location.origin : 'http://localhost:8000';\n  try {\n    var _response$body;\n    const response = await fetch(`${baseUrl}/chat/stream`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        messages: messages.map(convertToBackendMessage),\n        session_id: crypto.randomUUID()\n      }),\n      signal\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const reader = (_response$body = response.body) === null || _response$body === void 0 ? void 0 : _response$body.getReader();\n    if (!reader) {\n      throw new Error('No response body');\n    }\n    const decoder = new TextDecoder();\n    let accumulatedContent = '';\n    while (true) {\n      const {\n        done,\n        value\n      } = await reader.read();\n      if (done) break;\n      const chunk = decoder.decode(value);\n      const lines = chunk.split('\\n');\n      for (const line of lines) {\n        if (line.startsWith('data: ')) {\n          const data = line.slice(6);\n          if (data === '[DONE]') {\n            return accumulatedContent;\n          }\n          try {\n            const parsedChunk = JSON.parse(data);\n            if (parsedChunk.type === 'content' && parsedChunk.content) {\n              accumulatedContent += parsedChunk.content;\n              onUpdate(accumulatedContent);\n            }\n          } catch (e) {\n            console.warn('Failed to parse chunk:', data);\n          }\n        }\n      }\n    }\n    return accumulatedContent;\n  } catch (error) {\n    if (error.name !== 'AbortError') {\n      throw error;\n    }\n    return '';\n  }\n};","map":{"version":3,"names":["convertToBackendMessage","message","role","content","Array","isArray","map","part","type","text","join","timestamp","Date","toISOString","streamChatResponse","messages","onUpdate","signal","baseUrl","process","env","NODE_ENV","window","location","origin","_response$body","response","fetch","method","headers","body","JSON","stringify","session_id","crypto","randomUUID","ok","Error","status","reader","getReader","decoder","TextDecoder","accumulatedContent","done","value","read","chunk","decode","lines","split","line","startsWith","data","slice","parsedChunk","parse","e","console","warn","error","name"],"sources":["/workspace/frontend/src/lib/transport.ts"],"sourcesContent":["import { type CoreMessage } from \"@assistant-ui/react\";\n\n// Convert assistant-ui message format to our backend format\nconst convertToBackendMessage = (message: CoreMessage) => ({\n  role: message.role,\n  content: typeof message.content === 'string' \n    ? message.content \n    : Array.isArray(message.content)\n    ? message.content.map(part => \n        part.type === 'text' ? part.text : ''\n      ).join('')\n    : '',\n  timestamp: new Date().toISOString(),\n});\n\n// Simple fetch function for streaming\nexport const streamChatResponse = async (\n  messages: readonly CoreMessage[],\n  onUpdate: (content: string) => void,\n  signal?: AbortSignal\n) => {\n  const baseUrl = process.env.NODE_ENV === 'production' \n    ? window.location.origin \n    : 'http://localhost:8000';\n\n  try {\n    const response = await fetch(`${baseUrl}/chat/stream`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        messages: messages.map(convertToBackendMessage),\n        session_id: crypto.randomUUID(),\n      }),\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    const reader = response.body?.getReader();\n    if (!reader) {\n      throw new Error('No response body');\n    }\n\n    const decoder = new TextDecoder();\n    let accumulatedContent = '';\n\n    while (true) {\n      const { done, value } = await reader.read();\n      \n      if (done) break;\n\n      const chunk = decoder.decode(value);\n      const lines = chunk.split('\\n');\n\n      for (const line of lines) {\n        if (line.startsWith('data: ')) {\n          const data = line.slice(6);\n          \n          if (data === '[DONE]') {\n            return accumulatedContent;\n          }\n\n          try {\n            const parsedChunk = JSON.parse(data);\n            \n            if (parsedChunk.type === 'content' && parsedChunk.content) {\n              accumulatedContent += parsedChunk.content;\n              onUpdate(accumulatedContent);\n            }\n          } catch (e) {\n            console.warn('Failed to parse chunk:', data);\n          }\n        }\n      }\n    }\n\n    return accumulatedContent;\n  } catch (error: any) {\n    if (error.name !== 'AbortError') {\n      throw error;\n    }\n    return '';\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}