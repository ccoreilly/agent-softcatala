{"ast":null,"code":"// Simple message interface for our chat\n\n// Convert messages to backend format\nconst convertToBackendMessage = message => ({\n  role: message.role,\n  content: message.content,\n  timestamp: new Date().toISOString()\n});\n\n// Simple fetch function for streaming chat responses\nexport const streamChatResponse = async (messages, onUpdate, signal) => {\n  const baseUrl = process.env.NODE_ENV === 'production' ? window.location.origin : 'http://localhost:8000';\n  try {\n    var _response$body;\n    const response = await fetch(`${baseUrl}/chat/stream`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        messages: messages.map(convertToBackendMessage),\n        session_id: crypto.randomUUID()\n      }),\n      signal\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const reader = (_response$body = response.body) === null || _response$body === void 0 ? void 0 : _response$body.getReader();\n    if (!reader) {\n      throw new Error('No response body');\n    }\n    const decoder = new TextDecoder();\n    let accumulatedContent = '';\n    while (true) {\n      const {\n        done,\n        value\n      } = await reader.read();\n      if (done) break;\n      const chunk = decoder.decode(value);\n      const lines = chunk.split('\\n');\n      for (const line of lines) {\n        if (line.startsWith('data: ')) {\n          const data = line.slice(6);\n          if (data === '[DONE]') {\n            return accumulatedContent;\n          }\n          try {\n            const parsedChunk = JSON.parse(data);\n            if (parsedChunk.type === 'content' && parsedChunk.content) {\n              accumulatedContent += parsedChunk.content;\n              onUpdate(accumulatedContent);\n            }\n          } catch (e) {\n            console.warn('Failed to parse chunk:', data);\n          }\n        }\n      }\n    }\n    return accumulatedContent;\n  } catch (error) {\n    if (error.name !== 'AbortError') {\n      throw error;\n    }\n    return '';\n  }\n};","map":{"version":3,"names":["convertToBackendMessage","message","role","content","timestamp","Date","toISOString","streamChatResponse","messages","onUpdate","signal","baseUrl","process","env","NODE_ENV","window","location","origin","_response$body","response","fetch","method","headers","body","JSON","stringify","map","session_id","crypto","randomUUID","ok","Error","status","reader","getReader","decoder","TextDecoder","accumulatedContent","done","value","read","chunk","decode","lines","split","line","startsWith","data","slice","parsedChunk","parse","type","e","console","warn","error","name"],"sources":["/workspace/frontend/src/lib/transport.ts"],"sourcesContent":["// Simple message interface for our chat\nexport interface ChatMessage {\n  role: 'user' | 'assistant' | 'system';\n  content: string;\n}\n\n// Convert messages to backend format\nconst convertToBackendMessage = (message: ChatMessage) => ({\n  role: message.role,\n  content: message.content,\n  timestamp: new Date().toISOString(),\n});\n\n// Simple fetch function for streaming chat responses\nexport const streamChatResponse = async (\n  messages: ChatMessage[],\n  onUpdate: (content: string) => void,\n  signal?: AbortSignal\n) => {\n  const baseUrl = process.env.NODE_ENV === 'production' \n    ? window.location.origin \n    : 'http://localhost:8000';\n\n  try {\n    const response = await fetch(`${baseUrl}/chat/stream`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        messages: messages.map(convertToBackendMessage),\n        session_id: crypto.randomUUID(),\n      }),\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    const reader = response.body?.getReader();\n    if (!reader) {\n      throw new Error('No response body');\n    }\n\n    const decoder = new TextDecoder();\n    let accumulatedContent = '';\n\n    while (true) {\n      const { done, value } = await reader.read();\n      \n      if (done) break;\n\n      const chunk = decoder.decode(value);\n      const lines = chunk.split('\\n');\n\n      for (const line of lines) {\n        if (line.startsWith('data: ')) {\n          const data = line.slice(6);\n          \n          if (data === '[DONE]') {\n            return accumulatedContent;\n          }\n\n          try {\n            const parsedChunk = JSON.parse(data);\n            \n            if (parsedChunk.type === 'content' && parsedChunk.content) {\n              accumulatedContent += parsedChunk.content;\n              onUpdate(accumulatedContent);\n            }\n          } catch (e) {\n            console.warn('Failed to parse chunk:', data);\n          }\n        }\n      }\n    }\n\n    return accumulatedContent;\n  } catch (error: any) {\n    if (error.name !== 'AbortError') {\n      throw error;\n    }\n    return '';\n  }\n};"],"mappings":"AAAA;;AAMA;AACA,MAAMA,uBAAuB,GAAIC,OAAoB,KAAM;EACzDC,IAAI,EAAED,OAAO,CAACC,IAAI;EAClBC,OAAO,EAAEF,OAAO,CAACE,OAAO;EACxBC,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;AACpC,CAAC,CAAC;;AAEF;AACA,OAAO,MAAMC,kBAAkB,GAAG,MAAAA,CAChCC,QAAuB,EACvBC,QAAmC,EACnCC,MAAoB,KACjB;EACH,MAAMC,OAAO,GAAGC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GACjDC,MAAM,CAACC,QAAQ,CAACC,MAAM,GACtB,uBAAuB;EAE3B,IAAI;IAAA,IAAAC,cAAA;IACF,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAGT,OAAO,cAAc,EAAE;MACrDU,MAAM,EAAE,MAAM;MACdC,OAAO,EAAE;QACP,cAAc,EAAE;MAClB,CAAC;MACDC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;QACnBjB,QAAQ,EAAEA,QAAQ,CAACkB,GAAG,CAAC1B,uBAAuB,CAAC;QAC/C2B,UAAU,EAAEC,MAAM,CAACC,UAAU,CAAC;MAChC,CAAC,CAAC;MACFnB;IACF,CAAC,CAAC;IAEF,IAAI,CAACS,QAAQ,CAACW,EAAE,EAAE;MAChB,MAAM,IAAIC,KAAK,CAAC,uBAAuBZ,QAAQ,CAACa,MAAM,EAAE,CAAC;IAC3D;IAEA,MAAMC,MAAM,IAAAf,cAAA,GAAGC,QAAQ,CAACI,IAAI,cAAAL,cAAA,uBAAbA,cAAA,CAAegB,SAAS,CAAC,CAAC;IACzC,IAAI,CAACD,MAAM,EAAE;MACX,MAAM,IAAIF,KAAK,CAAC,kBAAkB,CAAC;IACrC;IAEA,MAAMI,OAAO,GAAG,IAAIC,WAAW,CAAC,CAAC;IACjC,IAAIC,kBAAkB,GAAG,EAAE;IAE3B,OAAO,IAAI,EAAE;MACX,MAAM;QAAEC,IAAI;QAAEC;MAAM,CAAC,GAAG,MAAMN,MAAM,CAACO,IAAI,CAAC,CAAC;MAE3C,IAAIF,IAAI,EAAE;MAEV,MAAMG,KAAK,GAAGN,OAAO,CAACO,MAAM,CAACH,KAAK,CAAC;MACnC,MAAMI,KAAK,GAAGF,KAAK,CAACG,KAAK,CAAC,IAAI,CAAC;MAE/B,KAAK,MAAMC,IAAI,IAAIF,KAAK,EAAE;QACxB,IAAIE,IAAI,CAACC,UAAU,CAAC,QAAQ,CAAC,EAAE;UAC7B,MAAMC,IAAI,GAAGF,IAAI,CAACG,KAAK,CAAC,CAAC,CAAC;UAE1B,IAAID,IAAI,KAAK,QAAQ,EAAE;YACrB,OAAOV,kBAAkB;UAC3B;UAEA,IAAI;YACF,MAAMY,WAAW,GAAGzB,IAAI,CAAC0B,KAAK,CAACH,IAAI,CAAC;YAEpC,IAAIE,WAAW,CAACE,IAAI,KAAK,SAAS,IAAIF,WAAW,CAAC9C,OAAO,EAAE;cACzDkC,kBAAkB,IAAIY,WAAW,CAAC9C,OAAO;cACzCM,QAAQ,CAAC4B,kBAAkB,CAAC;YAC9B;UACF,CAAC,CAAC,OAAOe,CAAC,EAAE;YACVC,OAAO,CAACC,IAAI,CAAC,wBAAwB,EAAEP,IAAI,CAAC;UAC9C;QACF;MACF;IACF;IAEA,OAAOV,kBAAkB;EAC3B,CAAC,CAAC,OAAOkB,KAAU,EAAE;IACnB,IAAIA,KAAK,CAACC,IAAI,KAAK,YAAY,EAAE;MAC/B,MAAMD,KAAK;IACb;IACA,OAAO,EAAE;EACX;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}